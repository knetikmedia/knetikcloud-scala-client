/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.knetikcloud.client.model

import java.text.SimpleDateFormat

import com.knetikcloud.client.model.EntitlementGrantRequest
import com.knetikcloud.client.model.EntitlementItem
import com.knetikcloud.client.model.InvoiceResource
import com.knetikcloud.client.model.ItemTemplateResource
import com.knetikcloud.client.model.PageResourceEntitlementItem
import com.knetikcloud.client.model.PageResourceItemTemplateResource
import com.knetikcloud.client.model.PageResourceUserInventoryResource
import com.knetikcloud.client.model.PageResourceUserItemLogResource
import com.knetikcloud.client.model.Result
import com.knetikcloud.client.model.UserInventoryAddRequest
import com.knetikcloud.client.model.UserInventoryResource
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

class UsersInventoryApi(val defBasePath: String = "https://devsandbox.knetikcloud.com",
                        defApiInvoker: ApiInvoker = ApiInvoker) {

  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS+0000")
  }
  implicit val stringReader = ClientResponseReaders.StringReader
  implicit val unitReader = ClientResponseReaders.UnitReader
  implicit val jvalueReader = ClientResponseReaders.JValueReader
  implicit val jsonReader = JsonFormatsReader
  implicit val stringWriter = RequestWriters.StringWriter
  implicit val jsonWriter = JsonFormatsWriter

  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value

  val config = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new UsersInventoryApiAsyncHelper(client, config)

  /**
   * Adds an item to the user inventory
   * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
   * @param id The id of the user 
   * @param userInventoryAddRequest The user inventory add request object (optional)
   * @return InvoiceResource
   */
  def addItemToUserInventory(id: Integer, userInventoryAddRequest: Option[UserInventoryAddRequest] = None): Option[InvoiceResource] = {
    val await = Try(Await.result(addItemToUserInventoryAsync(id, userInventoryAddRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds an item to the user inventory asynchronously
   * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
   * @param id The id of the user 
   * @param userInventoryAddRequest The user inventory add request object (optional)
   * @return Future(InvoiceResource)
  */
  def addItemToUserInventoryAsync(id: Integer, userInventoryAddRequest: Option[UserInventoryAddRequest] = None): Future[InvoiceResource] = {
      helper.addItemToUserInventory(id, userInventoryAddRequest)
  }


  /**
   * Check for access to an item without consuming
   * Useful for pre-check and accounts for all various buisness rules
   * @param userId The id of the user to check for or &#39;me&#39; for logged in user 
   * @param itemId The id of the item 
   * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out (optional)
   * @return void
   */
  def checkUserEntitlementItem(userId: String, itemId: Integer, sku: Option[String] = None) = {
    val await = Try(Await.result(checkUserEntitlementItemAsync(userId, itemId, sku), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Check for access to an item without consuming asynchronously
   * Useful for pre-check and accounts for all various buisness rules
   * @param userId The id of the user to check for or &#39;me&#39; for logged in user 
   * @param itemId The id of the item 
   * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out (optional)
   * @return Future(void)
  */
  def checkUserEntitlementItemAsync(userId: String, itemId: Integer, sku: Option[String] = None) = {
      helper.checkUserEntitlementItem(userId, itemId, sku)
  }


  /**
   * Create an entitlement item
   * 
   * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values. (optional, default to false)
   * @param entitlementItem The entitlement item object (optional)
   * @return EntitlementItem
   */
  def createEntitlementItem(cascade: Option[Boolean] /* = false*/, entitlementItem: Option[EntitlementItem] = None): Option[EntitlementItem] = {
    val await = Try(Await.result(createEntitlementItemAsync(cascade, entitlementItem), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create an entitlement item asynchronously
   * 
   * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values. (optional, default to false)
   * @param entitlementItem The entitlement item object (optional)
   * @return Future(EntitlementItem)
  */
  def createEntitlementItemAsync(cascade: Option[Boolean] /* = false*/, entitlementItem: Option[EntitlementItem] = None): Future[EntitlementItem] = {
      helper.createEntitlementItem(cascade, entitlementItem)
  }


  /**
   * Create an entitlement template
   * Entitlement templates define a type of entitlement and the properties they have
   * @param template The entitlement template to be created (optional)
   * @return ItemTemplateResource
   */
  def createEntitlementTemplate(template: Option[ItemTemplateResource] = None): Option[ItemTemplateResource] = {
    val await = Try(Await.result(createEntitlementTemplateAsync(template), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create an entitlement template asynchronously
   * Entitlement templates define a type of entitlement and the properties they have
   * @param template The entitlement template to be created (optional)
   * @return Future(ItemTemplateResource)
  */
  def createEntitlementTemplateAsync(template: Option[ItemTemplateResource] = None): Future[ItemTemplateResource] = {
      helper.createEntitlementTemplate(template)
  }


  /**
   * Delete an entitlement item
   * 
   * @param entitlementId The id of the entitlement 
   * @return void
   */
  def deleteEntitlementItem(entitlementId: Integer) = {
    val await = Try(Await.result(deleteEntitlementItemAsync(entitlementId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete an entitlement item asynchronously
   * 
   * @param entitlementId The id of the entitlement 
   * @return Future(void)
  */
  def deleteEntitlementItemAsync(entitlementId: Integer) = {
      helper.deleteEntitlementItem(entitlementId)
  }


  /**
   * Delete an entitlement template
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return void
   */
  def deleteEntitlementTemplate(id: String, cascade: Option[String] = None) = {
    val await = Try(Await.result(deleteEntitlementTemplateAsync(id, cascade), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete an entitlement template asynchronously
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return Future(void)
  */
  def deleteEntitlementTemplateAsync(id: String, cascade: Option[String] = None) = {
      helper.deleteEntitlementTemplate(id, cascade)
  }


  /**
   * Get a single entitlement item
   * 
   * @param entitlementId The id of the entitlement 
   * @return EntitlementItem
   */
  def getEntitlementItem(entitlementId: Integer): Option[EntitlementItem] = {
    val await = Try(Await.result(getEntitlementItemAsync(entitlementId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single entitlement item asynchronously
   * 
   * @param entitlementId The id of the entitlement 
   * @return Future(EntitlementItem)
  */
  def getEntitlementItemAsync(entitlementId: Integer): Future[EntitlementItem] = {
      helper.getEntitlementItem(entitlementId)
  }


  /**
   * List and search entitlement items
   * 
   * @param filterTemplate Filter for entitlements using a specified template (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceEntitlementItem
   */
  def getEntitlementItems(filterTemplate: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceEntitlementItem] = {
    val await = Try(Await.result(getEntitlementItemsAsync(filterTemplate, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search entitlement items asynchronously
   * 
   * @param filterTemplate Filter for entitlements using a specified template (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceEntitlementItem)
  */
  def getEntitlementItemsAsync(filterTemplate: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceEntitlementItem] = {
      helper.getEntitlementItems(filterTemplate, size, page, order)
  }


  /**
   * Get a single entitlement template
   * 
   * @param id The id of the template 
   * @return ItemTemplateResource
   */
  def getEntitlementTemplate(id: String): Option[ItemTemplateResource] = {
    val await = Try(Await.result(getEntitlementTemplateAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single entitlement template asynchronously
   * 
   * @param id The id of the template 
   * @return Future(ItemTemplateResource)
  */
  def getEntitlementTemplateAsync(id: String): Future[ItemTemplateResource] = {
      helper.getEntitlementTemplate(id)
  }


  /**
   * List and search entitlement templates
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceItemTemplateResource
   */
  def getEntitlementTemplates(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceItemTemplateResource] = {
    val await = Try(Await.result(getEntitlementTemplatesAsync(size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search entitlement templates asynchronously
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceItemTemplateResource)
  */
  def getEntitlementTemplatesAsync(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceItemTemplateResource] = {
      helper.getEntitlementTemplates(size, page, order)
  }


  /**
   * List the user inventory entries for a given user
   * 
   * @param id The id of the user 
   * @param inactive If true, accepts inactive user inventories (optional, default to false)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param filterItemName Filter by items whose name starts with a string (optional)
   * @param filterItemId Filter by item id (optional)
   * @param filterUsername Filter by entries owned by the user with the specified username (optional)
   * @param filterGroup Filter by entries owned by the users in a given group, by unique name (optional)
   * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @return PageResourceUserInventoryResource
   */
  def getUserInventories(id: Integer, inactive: Option[Boolean] /* = false*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, filterItemName: Option[String] = None, filterItemId: Option[Integer] = None, filterUsername: Option[String] = None, filterGroup: Option[String] = None, filterDate: Option[String] = None): Option[PageResourceUserInventoryResource] = {
    val await = Try(Await.result(getUserInventoriesAsync(id, inactive, size, page, filterItemName, filterItemId, filterUsername, filterGroup, filterDate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List the user inventory entries for a given user asynchronously
   * 
   * @param id The id of the user 
   * @param inactive If true, accepts inactive user inventories (optional, default to false)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param filterItemName Filter by items whose name starts with a string (optional)
   * @param filterItemId Filter by item id (optional)
   * @param filterUsername Filter by entries owned by the user with the specified username (optional)
   * @param filterGroup Filter by entries owned by the users in a given group, by unique name (optional)
   * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @return Future(PageResourceUserInventoryResource)
  */
  def getUserInventoriesAsync(id: Integer, inactive: Option[Boolean] /* = false*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, filterItemName: Option[String] = None, filterItemId: Option[Integer] = None, filterUsername: Option[String] = None, filterGroup: Option[String] = None, filterDate: Option[String] = None): Future[PageResourceUserInventoryResource] = {
      helper.getUserInventories(id, inactive, size, page, filterItemName, filterItemId, filterUsername, filterGroup, filterDate)
  }


  /**
   * Get an inventory entry
   * 
   * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user 
   * @param id The id of the user inventory 
   * @return UserInventoryResource
   */
  def getUserInventory(userId: Integer, id: Integer): Option[UserInventoryResource] = {
    val await = Try(Await.result(getUserInventoryAsync(userId, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get an inventory entry asynchronously
   * 
   * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user 
   * @param id The id of the user inventory 
   * @return Future(UserInventoryResource)
  */
  def getUserInventoryAsync(userId: Integer, id: Integer): Future[UserInventoryResource] = {
      helper.getUserInventory(userId, id)
  }


  /**
   * List the log entries for this inventory entry
   * 
   * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user 
   * @param id The id of the user inventory 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceUserItemLogResource
   */
  def getUserInventoryLog(userId: String, id: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceUserItemLogResource] = {
    val await = Try(Await.result(getUserInventoryLogAsync(userId, id, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List the log entries for this inventory entry asynchronously
   * 
   * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user 
   * @param id The id of the user inventory 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceUserItemLogResource)
  */
  def getUserInventoryLogAsync(userId: String, id: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceUserItemLogResource] = {
      helper.getUserInventoryLog(userId, id, size, page)
  }


  /**
   * List the user inventory entries for all users
   * 
   * @param inactive If true, accepts inactive user inventories (optional, default to false)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param filterItemName Filter by items whose name starts with a string (optional)
   * @param filterItemId Filter by item id (optional)
   * @param filterUsername Filter by entries owned by the user with the specified username (optional)
   * @param filterGroup Filter by entries owned by the users in a given group, by unique name (optional)
   * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @return PageResourceUserInventoryResource
   */
  def getUsersInventory(inactive: Option[Boolean] /* = false*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, filterItemName: Option[String] = None, filterItemId: Option[Integer] = None, filterUsername: Option[String] = None, filterGroup: Option[String] = None, filterDate: Option[String] = None): Option[PageResourceUserInventoryResource] = {
    val await = Try(Await.result(getUsersInventoryAsync(inactive, size, page, filterItemName, filterItemId, filterUsername, filterGroup, filterDate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List the user inventory entries for all users asynchronously
   * 
   * @param inactive If true, accepts inactive user inventories (optional, default to false)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param filterItemName Filter by items whose name starts with a string (optional)
   * @param filterItemId Filter by item id (optional)
   * @param filterUsername Filter by entries owned by the user with the specified username (optional)
   * @param filterGroup Filter by entries owned by the users in a given group, by unique name (optional)
   * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @return Future(PageResourceUserInventoryResource)
  */
  def getUsersInventoryAsync(inactive: Option[Boolean] /* = false*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, filterItemName: Option[String] = None, filterItemId: Option[Integer] = None, filterUsername: Option[String] = None, filterGroup: Option[String] = None, filterDate: Option[String] = None): Future[PageResourceUserInventoryResource] = {
      helper.getUsersInventory(inactive, size, page, filterItemName, filterItemId, filterUsername, filterGroup, filterDate)
  }


  /**
   * Grant an entitlement
   * 
   * @param userId The id of the user to grant the entitlement to 
   * @param grantRequest grantRequest 
   * @return void
   */
  def grantUserEntitlement(userId: Integer, grantRequest: EntitlementGrantRequest) = {
    val await = Try(Await.result(grantUserEntitlementAsync(userId, grantRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Grant an entitlement asynchronously
   * 
   * @param userId The id of the user to grant the entitlement to 
   * @param grantRequest grantRequest 
   * @return Future(void)
  */
  def grantUserEntitlementAsync(userId: Integer, grantRequest: EntitlementGrantRequest) = {
      helper.grantUserEntitlement(userId, grantRequest)
  }


  /**
   * Update an entitlement item
   * 
   * @param entitlementId The id of the entitlement 
   * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values. (optional, default to false)
   * @param entitlementItem The entitlement item object (optional)
   * @return void
   */
  def updateEntitlementItem(entitlementId: Integer, cascade: Option[Boolean] /* = false*/, entitlementItem: Option[EntitlementItem] = None) = {
    val await = Try(Await.result(updateEntitlementItemAsync(entitlementId, cascade, entitlementItem), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update an entitlement item asynchronously
   * 
   * @param entitlementId The id of the entitlement 
   * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values. (optional, default to false)
   * @param entitlementItem The entitlement item object (optional)
   * @return Future(void)
  */
  def updateEntitlementItemAsync(entitlementId: Integer, cascade: Option[Boolean] /* = false*/, entitlementItem: Option[EntitlementItem] = None) = {
      helper.updateEntitlementItem(entitlementId, cascade, entitlementItem)
  }


  /**
   * Update an entitlement template
   * 
   * @param id The id of the template 
   * @param template The updated template (optional)
   * @return ItemTemplateResource
   */
  def updateEntitlementTemplate(id: String, template: Option[ItemTemplateResource] = None): Option[ItemTemplateResource] = {
    val await = Try(Await.result(updateEntitlementTemplateAsync(id, template), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update an entitlement template asynchronously
   * 
   * @param id The id of the template 
   * @param template The updated template (optional)
   * @return Future(ItemTemplateResource)
  */
  def updateEntitlementTemplateAsync(id: String, template: Option[ItemTemplateResource] = None): Future[ItemTemplateResource] = {
      helper.updateEntitlementTemplate(id, template)
  }


  /**
   * Set the behavior data for an inventory entry
   * 
   * @param userId The id of the user 
   * @param id The id of the user inventory 
   * @param data The data map (optional)
   * @return void
   */
  def updateUserInventoryBehaviorData(userId: Integer, id: Integer, data: Option[Any] = None) = {
    val await = Try(Await.result(updateUserInventoryBehaviorDataAsync(userId, id, data), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the behavior data for an inventory entry asynchronously
   * 
   * @param userId The id of the user 
   * @param id The id of the user inventory 
   * @param data The data map (optional)
   * @return Future(void)
  */
  def updateUserInventoryBehaviorDataAsync(userId: Integer, id: Integer, data: Option[Any] = None) = {
      helper.updateUserInventoryBehaviorData(userId, id, data)
  }


  /**
   * Set the expiration date
   * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
   * @param userId user_id 
   * @param id The id of the user inventory 
   * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body). (optional)
   * @return void
   */
  def updateUserInventoryExpires(userId: Integer, id: Integer, timestamp: Option[Long] = None) = {
    val await = Try(Await.result(updateUserInventoryExpiresAsync(userId, id, timestamp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the expiration date asynchronously
   * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
   * @param userId user_id 
   * @param id The id of the user inventory 
   * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body). (optional)
   * @return Future(void)
  */
  def updateUserInventoryExpiresAsync(userId: Integer, id: Integer, timestamp: Option[Long] = None) = {
      helper.updateUserInventoryExpires(userId, id, timestamp)
  }


  /**
   * Set the status for an inventory entry
   * 
   * @param userId The id of the user 
   * @param id The id of the user inventory 
   * @param inventoryStatus The inventory status object (optional)
   * @return void
   */
  def updateUserInventoryStatus(userId: Integer, id: Integer, inventoryStatus: Option[String] = None) = {
    val await = Try(Await.result(updateUserInventoryStatusAsync(userId, id, inventoryStatus), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the status for an inventory entry asynchronously
   * 
   * @param userId The id of the user 
   * @param id The id of the user inventory 
   * @param inventoryStatus The inventory status object (optional)
   * @return Future(void)
  */
  def updateUserInventoryStatusAsync(userId: Integer, id: Integer, inventoryStatus: Option[String] = None) = {
      helper.updateUserInventoryStatus(userId, id, inventoryStatus)
  }


  /**
   * Use an item
   * 
   * @param userId The id of the user to check for or &#39;me&#39; for logged in user 
   * @param itemId The id of the item 
   * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out (optional)
   * @param info Any additional info to add to the log about this use (optional)
   * @return void
   */
  def useUserEntitlementItem(userId: String, itemId: Integer, sku: Option[String] = None, info: Option[String] = None) = {
    val await = Try(Await.result(useUserEntitlementItemAsync(userId, itemId, sku, info), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Use an item asynchronously
   * 
   * @param userId The id of the user to check for or &#39;me&#39; for logged in user 
   * @param itemId The id of the item 
   * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out (optional)
   * @param info Any additional info to add to the log about this use (optional)
   * @return Future(void)
  */
  def useUserEntitlementItemAsync(userId: String, itemId: Integer, sku: Option[String] = None, info: Option[String] = None) = {
      helper.useUserEntitlementItem(userId, itemId, sku, info)
  }


}

class UsersInventoryApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addItemToUserInventory(id: Integer,
    userInventoryAddRequest: Option[UserInventoryAddRequest] = None
    )(implicit reader: ClientResponseReader[InvoiceResource], writer: RequestWriter[UserInventoryAddRequest]): Future[InvoiceResource] = {
    // create path and map variables
    val path = (addFmt("/users/{id}/inventory")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(userInventoryAddRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def checkUserEntitlementItem(userId: String,
    itemId: Integer,
    sku: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/entitlements/{item_id}/check")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "item_id" + "\\}",itemId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (userId == null) throw new Exception("Missing required parameter 'userId' when calling UsersInventoryApi->checkUserEntitlementItem")

    sku match {
      case Some(param) => queryParams += "sku" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createEntitlementItem(cascade: Option[Boolean] = Some(false),
    entitlementItem: Option[EntitlementItem] = None
    )(implicit reader: ClientResponseReader[EntitlementItem], writer: RequestWriter[EntitlementItem]): Future[EntitlementItem] = {
    // create path and map variables
    val path = (addFmt("/entitlements"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    cascade match {
      case Some(param) => queryParams += "cascade" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(entitlementItem))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createEntitlementTemplate(template: Option[ItemTemplateResource] = None
    )(implicit reader: ClientResponseReader[ItemTemplateResource], writer: RequestWriter[ItemTemplateResource]): Future[ItemTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/entitlements/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(template))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteEntitlementItem(entitlementId: Integer)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/entitlements/{entitlement_id}")
      replaceAll ("\\{" + "entitlement_id" + "\\}",entitlementId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteEntitlementTemplate(id: String,
    cascade: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/entitlements/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersInventoryApi->deleteEntitlementTemplate")

    cascade match {
      case Some(param) => queryParams += "cascade" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitlementItem(entitlementId: Integer)(implicit reader: ClientResponseReader[EntitlementItem]): Future[EntitlementItem] = {
    // create path and map variables
    val path = (addFmt("/entitlements/{entitlement_id}")
      replaceAll ("\\{" + "entitlement_id" + "\\}",entitlementId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitlementItems(filterTemplate: Option[String] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceEntitlementItem]): Future[PageResourceEntitlementItem] = {
    // create path and map variables
    val path = (addFmt("/entitlements"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    filterTemplate match {
      case Some(param) => queryParams += "filter_template" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitlementTemplate(id: String)(implicit reader: ClientResponseReader[ItemTemplateResource]): Future[ItemTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/entitlements/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersInventoryApi->getEntitlementTemplate")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitlementTemplates(size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceItemTemplateResource]): Future[PageResourceItemTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/entitlements/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserInventories(id: Integer,
    inactive: Option[Boolean] = Some(false),
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    filterItemName: Option[String] = None,
    filterItemId: Option[Integer] = None,
    filterUsername: Option[String] = None,
    filterGroup: Option[String] = None,
    filterDate: Option[String] = None
    )(implicit reader: ClientResponseReader[PageResourceUserInventoryResource]): Future[PageResourceUserInventoryResource] = {
    // create path and map variables
    val path = (addFmt("/users/{id}/inventory")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    inactive match {
      case Some(param) => queryParams += "inactive" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    filterItemName match {
      case Some(param) => queryParams += "filter_item_name" -> param.toString
      case _ => queryParams
    }
    filterItemId match {
      case Some(param) => queryParams += "filter_item_id" -> param.toString
      case _ => queryParams
    }
    filterUsername match {
      case Some(param) => queryParams += "filter_username" -> param.toString
      case _ => queryParams
    }
    filterGroup match {
      case Some(param) => queryParams += "filter_group" -> param.toString
      case _ => queryParams
    }
    filterDate match {
      case Some(param) => queryParams += "filter_date" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserInventory(userId: Integer,
    id: Integer)(implicit reader: ClientResponseReader[UserInventoryResource]): Future[UserInventoryResource] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/inventory/{id}")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserInventoryLog(userId: String,
    id: Integer,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceUserItemLogResource]): Future[PageResourceUserItemLogResource] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/inventory/{id}/log")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (userId == null) throw new Exception("Missing required parameter 'userId' when calling UsersInventoryApi->getUserInventoryLog")

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUsersInventory(inactive: Option[Boolean] = Some(false),
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    filterItemName: Option[String] = None,
    filterItemId: Option[Integer] = None,
    filterUsername: Option[String] = None,
    filterGroup: Option[String] = None,
    filterDate: Option[String] = None
    )(implicit reader: ClientResponseReader[PageResourceUserInventoryResource]): Future[PageResourceUserInventoryResource] = {
    // create path and map variables
    val path = (addFmt("/inventories"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    inactive match {
      case Some(param) => queryParams += "inactive" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    filterItemName match {
      case Some(param) => queryParams += "filter_item_name" -> param.toString
      case _ => queryParams
    }
    filterItemId match {
      case Some(param) => queryParams += "filter_item_id" -> param.toString
      case _ => queryParams
    }
    filterUsername match {
      case Some(param) => queryParams += "filter_username" -> param.toString
      case _ => queryParams
    }
    filterGroup match {
      case Some(param) => queryParams += "filter_group" -> param.toString
      case _ => queryParams
    }
    filterDate match {
      case Some(param) => queryParams += "filter_date" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def grantUserEntitlement(userId: Integer,
    grantRequest: EntitlementGrantRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[EntitlementGrantRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/entitlements")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (grantRequest == null) throw new Exception("Missing required parameter 'grantRequest' when calling UsersInventoryApi->grantUserEntitlement")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(grantRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateEntitlementItem(entitlementId: Integer,
    cascade: Option[Boolean] = Some(false),
    entitlementItem: Option[EntitlementItem] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[EntitlementItem]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/entitlements/{entitlement_id}")
      replaceAll ("\\{" + "entitlement_id" + "\\}",entitlementId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    cascade match {
      case Some(param) => queryParams += "cascade" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(entitlementItem))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateEntitlementTemplate(id: String,
    template: Option[ItemTemplateResource] = None
    )(implicit reader: ClientResponseReader[ItemTemplateResource], writer: RequestWriter[ItemTemplateResource]): Future[ItemTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/entitlements/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersInventoryApi->updateEntitlementTemplate")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(template))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUserInventoryBehaviorData(userId: Integer,
    id: Integer,
    data: Option[Any] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Any]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/inventory/{id}/behavior-data")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(data))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUserInventoryExpires(userId: Integer,
    id: Integer,
    timestamp: Option[Long] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Long]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/inventory/{id}/expires")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(timestamp))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUserInventoryStatus(userId: Integer,
    id: Integer,
    inventoryStatus: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[String]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/inventory/{id}/status")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(inventoryStatus))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def useUserEntitlementItem(userId: String,
    itemId: Integer,
    sku: Option[String] = None,
    info: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/entitlements/{item_id}/use")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "item_id" + "\\}",itemId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (userId == null) throw new Exception("Missing required parameter 'userId' when calling UsersInventoryApi->useUserEntitlementItem")

    sku match {
      case Some(param) => queryParams += "sku" -> param.toString
      case _ => queryParams
    }
    info match {
      case Some(param) => queryParams += "info" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
