/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.knetikcloud.client.model

import java.text.SimpleDateFormat

import com.knetikcloud.client.model.ActivityOccurrenceCreationFailure
import com.knetikcloud.client.model.ActivityOccurrenceResource
import com.knetikcloud.client.model.ActivityOccurrenceResults
import com.knetikcloud.client.model.ActivityOccurrenceResultsResource
import com.knetikcloud.client.model.ActivityResource
import com.knetikcloud.client.model.CreateActivityOccurrenceRequest
import com.knetikcloud.client.model.PageResourceActivityOccurrenceResource
import com.knetikcloud.client.model.PageResourceBareActivityResource
import com.knetikcloud.client.model.PageResourceTemplateResource
import com.knetikcloud.client.model.Result
import com.knetikcloud.client.model.TemplateResource
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

class ActivitiesApi(val defBasePath: String = "https://devsandbox.knetikcloud.com",
                        defApiInvoker: ApiInvoker = ApiInvoker) {

  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS+0000")
  }
  implicit val stringReader = ClientResponseReaders.StringReader
  implicit val unitReader = ClientResponseReaders.UnitReader
  implicit val jvalueReader = ClientResponseReaders.JValueReader
  implicit val jsonReader = JsonFormatsReader
  implicit val stringWriter = RequestWriters.StringWriter
  implicit val jsonWriter = JsonFormatsWriter

  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value

  val config = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ActivitiesApiAsyncHelper(client, config)

  /**
   * Create an activity
   * 
   * @param activityResource The activity resource object (optional)
   * @return ActivityResource
   */
  def createActivity(activityResource: Option[ActivityResource] = None): Option[ActivityResource] = {
    val await = Try(Await.result(createActivityAsync(activityResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create an activity asynchronously
   * 
   * @param activityResource The activity resource object (optional)
   * @return Future(ActivityResource)
  */
  def createActivityAsync(activityResource: Option[ActivityResource] = None): Future[ActivityResource] = {
      helper.createActivity(activityResource)
  }


  /**
   * Create a new activity occurrence. Ex: start a game
   * Has to enforce extra rules if not used as an admin
   * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings (optional, default to false)
   * @param activityOccurrenceResource The activity occurrence object (optional)
   * @return ActivityOccurrenceResource
   */
  def createActivityOccurrence(test: Option[Boolean] /* = false*/, activityOccurrenceResource: Option[CreateActivityOccurrenceRequest] = None): Option[ActivityOccurrenceResource] = {
    val await = Try(Await.result(createActivityOccurrenceAsync(test, activityOccurrenceResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a new activity occurrence. Ex: start a game asynchronously
   * Has to enforce extra rules if not used as an admin
   * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings (optional, default to false)
   * @param activityOccurrenceResource The activity occurrence object (optional)
   * @return Future(ActivityOccurrenceResource)
  */
  def createActivityOccurrenceAsync(test: Option[Boolean] /* = false*/, activityOccurrenceResource: Option[CreateActivityOccurrenceRequest] = None): Future[ActivityOccurrenceResource] = {
      helper.createActivityOccurrence(test, activityOccurrenceResource)
  }


  /**
   * Create a activity template
   * Activity Templates define a type of activity and the properties they have
   * @param activityTemplateResource The activity template resource object (optional)
   * @return TemplateResource
   */
  def createActivityTemplate(activityTemplateResource: Option[TemplateResource] = None): Option[TemplateResource] = {
    val await = Try(Await.result(createActivityTemplateAsync(activityTemplateResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a activity template asynchronously
   * Activity Templates define a type of activity and the properties they have
   * @param activityTemplateResource The activity template resource object (optional)
   * @return Future(TemplateResource)
  */
  def createActivityTemplateAsync(activityTemplateResource: Option[TemplateResource] = None): Future[TemplateResource] = {
      helper.createActivityTemplate(activityTemplateResource)
  }


  /**
   * Delete an activity
   * 
   * @param id The id of the activity 
   * @return void
   */
  def deleteActivity(id: Long) = {
    val await = Try(Await.result(deleteActivityAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete an activity asynchronously
   * 
   * @param id The id of the activity 
   * @return Future(void)
  */
  def deleteActivityAsync(id: Long) = {
      helper.deleteActivity(id)
  }


  /**
   * Delete a activity template
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return void
   */
  def deleteActivityTemplate(id: String, cascade: Option[String] = None) = {
    val await = Try(Await.result(deleteActivityTemplateAsync(id, cascade), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a activity template asynchronously
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return Future(void)
  */
  def deleteActivityTemplateAsync(id: String, cascade: Option[String] = None) = {
      helper.deleteActivityTemplate(id, cascade)
  }


  /**
   * List activity definitions
   * 
   * @param filterTemplate Filter for activities that are templates, or specifically not if false (optional)
   * @param filterName Filter for activities that have a name starting with specified string (optional)
   * @param filterId Filter for activities with an id in the given comma separated list of ids (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceBareActivityResource
   */
  def getActivities(filterTemplate: Option[Boolean] = None, filterName: Option[String] = None, filterId: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceBareActivityResource] = {
    val await = Try(Await.result(getActivitiesAsync(filterTemplate, filterName, filterId, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List activity definitions asynchronously
   * 
   * @param filterTemplate Filter for activities that are templates, or specifically not if false (optional)
   * @param filterName Filter for activities that have a name starting with specified string (optional)
   * @param filterId Filter for activities with an id in the given comma separated list of ids (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceBareActivityResource)
  */
  def getActivitiesAsync(filterTemplate: Option[Boolean] = None, filterName: Option[String] = None, filterId: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceBareActivityResource] = {
      helper.getActivities(filterTemplate, filterName, filterId, size, page, order)
  }


  /**
   * Get a single activity
   * 
   * @param id The id of the activity 
   * @return ActivityResource
   */
  def getActivity(id: Long): Option[ActivityResource] = {
    val await = Try(Await.result(getActivityAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single activity asynchronously
   * 
   * @param id The id of the activity 
   * @return Future(ActivityResource)
  */
  def getActivityAsync(id: Long): Future[ActivityResource] = {
      helper.getActivity(id)
  }


  /**
   * Load a single activity occurrence details
   * 
   * @param activityOccurrenceId The id of the activity occurrence 
   * @return ActivityOccurrenceResource
   */
  def getActivityOccurrenceDetails(activityOccurrenceId: Long): Option[ActivityOccurrenceResource] = {
    val await = Try(Await.result(getActivityOccurrenceDetailsAsync(activityOccurrenceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Load a single activity occurrence details asynchronously
   * 
   * @param activityOccurrenceId The id of the activity occurrence 
   * @return Future(ActivityOccurrenceResource)
  */
  def getActivityOccurrenceDetailsAsync(activityOccurrenceId: Long): Future[ActivityOccurrenceResource] = {
      helper.getActivityOccurrenceDetails(activityOccurrenceId)
  }


  /**
   * Get a single activity template
   * 
   * @param id The id of the template 
   * @return TemplateResource
   */
  def getActivityTemplate(id: String): Option[TemplateResource] = {
    val await = Try(Await.result(getActivityTemplateAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single activity template asynchronously
   * 
   * @param id The id of the template 
   * @return Future(TemplateResource)
  */
  def getActivityTemplateAsync(id: String): Future[TemplateResource] = {
      helper.getActivityTemplate(id)
  }


  /**
   * List and search activity templates
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceTemplateResource
   */
  def getActivityTemplates(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceTemplateResource] = {
    val await = Try(Await.result(getActivityTemplatesAsync(size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search activity templates asynchronously
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceTemplateResource)
  */
  def getActivityTemplatesAsync(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceTemplateResource] = {
      helper.getActivityTemplates(size, page, order)
  }


  /**
   * List activity occurrences
   * 
   * @param filterActivity Filter for occurrences of the given activity ID (optional)
   * @param filterStatus Filter for occurrences of the given activity ID (optional)
   * @param filterEvent Filter for occurrences played during the given event (optional)
   * @param filterChallenge Filter for occurrences played within the given challenge (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceActivityOccurrenceResource
   */
  def listActivityOccurrences(filterActivity: Option[String] = None, filterStatus: Option[String] = None, filterEvent: Option[Integer] = None, filterChallenge: Option[Integer] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceActivityOccurrenceResource] = {
    val await = Try(Await.result(listActivityOccurrencesAsync(filterActivity, filterStatus, filterEvent, filterChallenge, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List activity occurrences asynchronously
   * 
   * @param filterActivity Filter for occurrences of the given activity ID (optional)
   * @param filterStatus Filter for occurrences of the given activity ID (optional)
   * @param filterEvent Filter for occurrences played during the given event (optional)
   * @param filterChallenge Filter for occurrences played within the given challenge (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceActivityOccurrenceResource)
  */
  def listActivityOccurrencesAsync(filterActivity: Option[String] = None, filterStatus: Option[String] = None, filterEvent: Option[Integer] = None, filterChallenge: Option[Integer] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceActivityOccurrenceResource] = {
      helper.listActivityOccurrences(filterActivity, filterStatus, filterEvent, filterChallenge, size, page, order)
  }


  /**
   * Sets the status of an activity occurrence to FINISHED and logs metrics
   * 
   * @param activityOccurrenceId The id of the activity occurrence 
   * @param activityOccurrenceResults The activity occurrence object (optional)
   * @return ActivityOccurrenceResults
   */
  def setActivityOccurrenceResults(activityOccurrenceId: Long, activityOccurrenceResults: Option[ActivityOccurrenceResultsResource] = None): Option[ActivityOccurrenceResults] = {
    val await = Try(Await.result(setActivityOccurrenceResultsAsync(activityOccurrenceId, activityOccurrenceResults), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets the status of an activity occurrence to FINISHED and logs metrics asynchronously
   * 
   * @param activityOccurrenceId The id of the activity occurrence 
   * @param activityOccurrenceResults The activity occurrence object (optional)
   * @return Future(ActivityOccurrenceResults)
  */
  def setActivityOccurrenceResultsAsync(activityOccurrenceId: Long, activityOccurrenceResults: Option[ActivityOccurrenceResultsResource] = None): Future[ActivityOccurrenceResults] = {
      helper.setActivityOccurrenceResults(activityOccurrenceId, activityOccurrenceResults)
  }


  /**
   * Update an activity
   * 
   * @param id The id of the activity 
   * @param activityResource The activity resource object (optional)
   * @return ActivityResource
   */
  def updateActivity(id: Long, activityResource: Option[ActivityResource] = None): Option[ActivityResource] = {
    val await = Try(Await.result(updateActivityAsync(id, activityResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update an activity asynchronously
   * 
   * @param id The id of the activity 
   * @param activityResource The activity resource object (optional)
   * @return Future(ActivityResource)
  */
  def updateActivityAsync(id: Long, activityResource: Option[ActivityResource] = None): Future[ActivityResource] = {
      helper.updateActivity(id, activityResource)
  }


  /**
   * Updated the status of an activity occurrence
   * If setting to &#39;FINISHED&#39; reward will be run based on current metrics that have been recorded already. Aternatively, see results endpoint to finish and record all metrics at once.
   * @param activityOccurrenceId The id of the activity occurrence 
   * @param activityOccurrenceStatus The activity occurrence status object (optional)
   * @return void
   */
  def updateActivityOccurrence(activityOccurrenceId: Long, activityOccurrenceStatus: Option[String] = None) = {
    val await = Try(Await.result(updateActivityOccurrenceAsync(activityOccurrenceId, activityOccurrenceStatus), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updated the status of an activity occurrence asynchronously
   * If setting to &#39;FINISHED&#39; reward will be run based on current metrics that have been recorded already. Aternatively, see results endpoint to finish and record all metrics at once.
   * @param activityOccurrenceId The id of the activity occurrence 
   * @param activityOccurrenceStatus The activity occurrence status object (optional)
   * @return Future(void)
  */
  def updateActivityOccurrenceAsync(activityOccurrenceId: Long, activityOccurrenceStatus: Option[String] = None) = {
      helper.updateActivityOccurrence(activityOccurrenceId, activityOccurrenceStatus)
  }


  /**
   * Update an activity template
   * 
   * @param id The id of the template 
   * @param activityTemplateResource The activity template resource object (optional)
   * @return TemplateResource
   */
  def updateActivityTemplate(id: String, activityTemplateResource: Option[TemplateResource] = None): Option[TemplateResource] = {
    val await = Try(Await.result(updateActivityTemplateAsync(id, activityTemplateResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update an activity template asynchronously
   * 
   * @param id The id of the template 
   * @param activityTemplateResource The activity template resource object (optional)
   * @return Future(TemplateResource)
  */
  def updateActivityTemplateAsync(id: String, activityTemplateResource: Option[TemplateResource] = None): Future[TemplateResource] = {
      helper.updateActivityTemplate(id, activityTemplateResource)
  }


}

class ActivitiesApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def createActivity(activityResource: Option[ActivityResource] = None
    )(implicit reader: ClientResponseReader[ActivityResource], writer: RequestWriter[ActivityResource]): Future[ActivityResource] = {
    // create path and map variables
    val path = (addFmt("/activities"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(activityResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createActivityOccurrence(test: Option[Boolean] = Some(false),
    activityOccurrenceResource: Option[CreateActivityOccurrenceRequest] = None
    )(implicit reader: ClientResponseReader[ActivityOccurrenceResource], writer: RequestWriter[CreateActivityOccurrenceRequest]): Future[ActivityOccurrenceResource] = {
    // create path and map variables
    val path = (addFmt("/activity-occurrences"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    test match {
      case Some(param) => queryParams += "test" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(activityOccurrenceResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createActivityTemplate(activityTemplateResource: Option[TemplateResource] = None
    )(implicit reader: ClientResponseReader[TemplateResource], writer: RequestWriter[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/activities/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(activityTemplateResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteActivity(id: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/activities/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteActivityTemplate(id: String,
    cascade: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/activities/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling ActivitiesApi->deleteActivityTemplate")

    cascade match {
      case Some(param) => queryParams += "cascade" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getActivities(filterTemplate: Option[Boolean] = None,
    filterName: Option[String] = None,
    filterId: Option[String] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceBareActivityResource]): Future[PageResourceBareActivityResource] = {
    // create path and map variables
    val path = (addFmt("/activities"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    filterTemplate match {
      case Some(param) => queryParams += "filter_template" -> param.toString
      case _ => queryParams
    }
    filterName match {
      case Some(param) => queryParams += "filter_name" -> param.toString
      case _ => queryParams
    }
    filterId match {
      case Some(param) => queryParams += "filter_id" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getActivity(id: Long)(implicit reader: ClientResponseReader[ActivityResource]): Future[ActivityResource] = {
    // create path and map variables
    val path = (addFmt("/activities/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getActivityOccurrenceDetails(activityOccurrenceId: Long)(implicit reader: ClientResponseReader[ActivityOccurrenceResource]): Future[ActivityOccurrenceResource] = {
    // create path and map variables
    val path = (addFmt("/activity-occurrences/{activity_occurrence_id}")
      replaceAll ("\\{" + "activity_occurrence_id" + "\\}",activityOccurrenceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getActivityTemplate(id: String)(implicit reader: ClientResponseReader[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/activities/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling ActivitiesApi->getActivityTemplate")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getActivityTemplates(size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceTemplateResource]): Future[PageResourceTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/activities/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listActivityOccurrences(filterActivity: Option[String] = None,
    filterStatus: Option[String] = None,
    filterEvent: Option[Integer] = None,
    filterChallenge: Option[Integer] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceActivityOccurrenceResource]): Future[PageResourceActivityOccurrenceResource] = {
    // create path and map variables
    val path = (addFmt("/activity-occurrences"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    filterActivity match {
      case Some(param) => queryParams += "filter_activity" -> param.toString
      case _ => queryParams
    }
    filterStatus match {
      case Some(param) => queryParams += "filter_status" -> param.toString
      case _ => queryParams
    }
    filterEvent match {
      case Some(param) => queryParams += "filter_event" -> param.toString
      case _ => queryParams
    }
    filterChallenge match {
      case Some(param) => queryParams += "filter_challenge" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setActivityOccurrenceResults(activityOccurrenceId: Long,
    activityOccurrenceResults: Option[ActivityOccurrenceResultsResource] = None
    )(implicit reader: ClientResponseReader[ActivityOccurrenceResults], writer: RequestWriter[ActivityOccurrenceResultsResource]): Future[ActivityOccurrenceResults] = {
    // create path and map variables
    val path = (addFmt("/activity-occurrences/{activity_occurrence_id}/results")
      replaceAll ("\\{" + "activity_occurrence_id" + "\\}",activityOccurrenceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(activityOccurrenceResults))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateActivity(id: Long,
    activityResource: Option[ActivityResource] = None
    )(implicit reader: ClientResponseReader[ActivityResource], writer: RequestWriter[ActivityResource]): Future[ActivityResource] = {
    // create path and map variables
    val path = (addFmt("/activities/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(activityResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateActivityOccurrence(activityOccurrenceId: Long,
    activityOccurrenceStatus: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[String]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/activity-occurrences/{activity_occurrence_id}/status")
      replaceAll ("\\{" + "activity_occurrence_id" + "\\}",activityOccurrenceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(activityOccurrenceStatus))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateActivityTemplate(id: String,
    activityTemplateResource: Option[TemplateResource] = None
    )(implicit reader: ClientResponseReader[TemplateResource], writer: RequestWriter[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/activities/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling ActivitiesApi->updateActivityTemplate")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(activityTemplateResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
