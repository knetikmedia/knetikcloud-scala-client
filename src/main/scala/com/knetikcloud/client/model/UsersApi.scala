/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.knetikcloud.client.model

import java.text.SimpleDateFormat

import com.knetikcloud.client.model.ChatMessageRequest
import com.knetikcloud.client.model.ChatMessageResource
import com.knetikcloud.client.model.NewPasswordRequest
import com.knetikcloud.client.model.PageResourceChatMessageResource
import com.knetikcloud.client.model.PageResourceTemplateResource
import com.knetikcloud.client.model.PageResourceUserBaseResource
import com.knetikcloud.client.model.PasswordResetRequest
import com.knetikcloud.client.model.Result
import com.knetikcloud.client.model.StringWrapper
import com.knetikcloud.client.model.TemplateResource
import com.knetikcloud.client.model.UserResource
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

class UsersApi(val defBasePath: String = "https://jsapi-integration.us-east-1.elasticbeanstalk.com",
                        defApiInvoker: ApiInvoker = ApiInvoker) {

  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS+0000")
  }
  implicit val stringReader = ClientResponseReaders.StringReader
  implicit val unitReader = ClientResponseReaders.UnitReader
  implicit val jvalueReader = ClientResponseReaders.JValueReader
  implicit val jsonReader = JsonFormatsReader
  implicit val stringWriter = RequestWriters.StringWriter
  implicit val jsonWriter = JsonFormatsWriter

  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value

  val config = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new UsersApiAsyncHelper(client, config)

  /**
   * Add a tag to a user
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN
   * @param userId The id of the user 
   * @param tag tag 
   * @return void
   */
  def addUserTag(userId: Integer, tag: StringWrapper) = {
    val await = Try(Await.result(addUserTagAsync(userId, tag), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a tag to a user asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN
   * @param userId The id of the user 
   * @param tag tag 
   * @return Future(void)
  */
  def addUserTagAsync(userId: Integer, tag: StringWrapper) = {
      helper.addUserTag(userId, tag)
  }


  /**
   * Create a user template
   * User Templates define a type of user and the properties they have. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param userTemplateResource The user template resource object (optional)
   * @return TemplateResource
   */
  def createUserTemplate(userTemplateResource: Option[TemplateResource] = None): Option[TemplateResource] = {
    val await = Try(Await.result(createUserTemplateAsync(userTemplateResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a user template asynchronously
   * User Templates define a type of user and the properties they have. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param userTemplateResource The user template resource object (optional)
   * @return Future(TemplateResource)
  */
  def createUserTemplateAsync(userTemplateResource: Option[TemplateResource] = None): Future[TemplateResource] = {
      helper.createUserTemplate(userTemplateResource)
  }


  /**
   * Delete a user template
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return void
   */
  def deleteUserTemplate(id: String, cascade: Option[String] = None) = {
    val await = Try(Await.result(deleteUserTemplateAsync(id, cascade), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a user template asynchronously
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return Future(void)
  */
  def deleteUserTemplateAsync(id: String, cascade: Option[String] = None) = {
      helper.deleteUserTemplate(id, cascade)
  }


  /**
   * Get a list of direct messages with this user
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param recipientId The user id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceChatMessageResource
   */
  def getDirectMessages1(recipientId: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceChatMessageResource] = {
    val await = Try(Await.result(getDirectMessages1Async(recipientId, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a list of direct messages with this user asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param recipientId The user id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceChatMessageResource)
  */
  def getDirectMessages1Async(recipientId: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceChatMessageResource] = {
      helper.getDirectMessages1(recipientId, size, page)
  }


  /**
   * Get a single user
   * Additional private info is included as USERS_ADMIN. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The id of the user or &#39;me&#39; 
   * @return UserResource
   */
  def getUser(id: String): Option[UserResource] = {
    val await = Try(Await.result(getUserAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single user asynchronously
   * Additional private info is included as USERS_ADMIN. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The id of the user or &#39;me&#39; 
   * @return Future(UserResource)
  */
  def getUserAsync(id: String): Future[UserResource] = {
      helper.getUser(id)
  }


  /**
   * List tags for a user
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN
   * @param userId The id of the user 
   * @return List[String]
   */
  def getUserTags(userId: Integer): Option[List[String]] = {
    val await = Try(Await.result(getUserTagsAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List tags for a user asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN
   * @param userId The id of the user 
   * @return Future(List[String])
  */
  def getUserTagsAsync(userId: Integer): Future[List[String]] = {
      helper.getUserTags(userId)
  }


  /**
   * Get a single user template
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or USERS_ADMIN
   * @param id The id of the template 
   * @return TemplateResource
   */
  def getUserTemplate(id: String): Option[TemplateResource] = {
    val await = Try(Await.result(getUserTemplateAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single user template asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or USERS_ADMIN
   * @param id The id of the template 
   * @return Future(TemplateResource)
  */
  def getUserTemplateAsync(id: String): Future[TemplateResource] = {
      helper.getUserTemplate(id)
  }


  /**
   * List and search user templates
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or USERS_ADMIN
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceTemplateResource
   */
  def getUserTemplates(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceTemplateResource] = {
    val await = Try(Await.result(getUserTemplatesAsync(size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search user templates asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or USERS_ADMIN
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceTemplateResource)
  */
  def getUserTemplatesAsync(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceTemplateResource] = {
      helper.getUserTemplates(size, page, order)
  }


  /**
   * List and search users
   * Additional private info is included as USERS_ADMIN. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param filterDisplayname Filter for users whose display name starts with provided string. (optional)
   * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission (optional)
   * @param filterTag Filter for users who have a given tag (optional)
   * @param filterGroup Filter for users in a given group, by unique name (optional)
   * @param filterRole Filter for users with a given role (optional)
   * @param filterLastActivity A comma separated string without spaces.  First value is the operator to search on, second value is the date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @param filterIdList A comma separated list of ids. (optional)
   * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceUserBaseResource
   */
  def getUsers(filterDisplayname: Option[String] = None, filterEmail: Option[String] = None, filterFirstname: Option[String] = None, filterFullname: Option[String] = None, filterLastname: Option[String] = None, filterUsername: Option[String] = None, filterTag: Option[String] = None, filterGroup: Option[String] = None, filterRole: Option[String] = None, filterLastActivity: Option[String] = None, filterIdList: Option[String] = None, filterSearch: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceUserBaseResource] = {
    val await = Try(Await.result(getUsersAsync(filterDisplayname, filterEmail, filterFirstname, filterFullname, filterLastname, filterUsername, filterTag, filterGroup, filterRole, filterLastActivity, filterIdList, filterSearch, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search users asynchronously
   * Additional private info is included as USERS_ADMIN. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param filterDisplayname Filter for users whose display name starts with provided string. (optional)
   * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission (optional)
   * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission (optional)
   * @param filterTag Filter for users who have a given tag (optional)
   * @param filterGroup Filter for users in a given group, by unique name (optional)
   * @param filterRole Filter for users with a given role (optional)
   * @param filterLastActivity A comma separated string without spaces.  First value is the operator to search on, second value is the date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @param filterIdList A comma separated list of ids. (optional)
   * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceUserBaseResource)
  */
  def getUsersAsync(filterDisplayname: Option[String] = None, filterEmail: Option[String] = None, filterFirstname: Option[String] = None, filterFullname: Option[String] = None, filterLastname: Option[String] = None, filterUsername: Option[String] = None, filterTag: Option[String] = None, filterGroup: Option[String] = None, filterRole: Option[String] = None, filterLastActivity: Option[String] = None, filterIdList: Option[String] = None, filterSearch: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceUserBaseResource] = {
      helper.getUsers(filterDisplayname, filterEmail, filterFirstname, filterFullname, filterLastname, filterUsername, filterTag, filterGroup, filterRole, filterLastActivity, filterIdList, filterSearch, size, page, order)
  }


  /**
   * Choose a new password after a reset
   * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The id of the user 
   * @param newPasswordRequest The new password request object (optional)
   * @return void
   */
  def passwordReset(id: Integer, newPasswordRequest: Option[NewPasswordRequest] = None) = {
    val await = Try(Await.result(passwordResetAsync(id, newPasswordRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Choose a new password after a reset asynchronously
   * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The id of the user 
   * @param newPasswordRequest The new password request object (optional)
   * @return Future(void)
  */
  def passwordResetAsync(id: Integer, newPasswordRequest: Option[NewPasswordRequest] = None) = {
      helper.passwordReset(id, newPasswordRequest)
  }


  /**
   * Send a user message
   * 
   * @param recipientId The user id 
   * @param chatMessageRequest The chat message request (optional)
   * @return ChatMessageResource
   */
  def postUserMessage(recipientId: Integer, chatMessageRequest: Option[ChatMessageRequest] = None): Option[ChatMessageResource] = {
    val await = Try(Await.result(postUserMessageAsync(recipientId, chatMessageRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Send a user message asynchronously
   * 
   * @param recipientId The user id 
   * @param chatMessageRequest The chat message request (optional)
   * @return Future(ChatMessageResource)
  */
  def postUserMessageAsync(recipientId: Integer, chatMessageRequest: Option[ChatMessageRequest] = None): Future[ChatMessageResource] = {
      helper.postUserMessage(recipientId, chatMessageRequest)
  }


  /**
   * Register a new user
   * Password should be in plain text and will be encrypted on receipt. Use SSL for security. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param userResource The user resource object (optional)
   * @return UserResource
   */
  def registerUser(userResource: Option[UserResource] = None): Option[UserResource] = {
    val await = Try(Await.result(registerUserAsync(userResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Register a new user asynchronously
   * Password should be in plain text and will be encrypted on receipt. Use SSL for security. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param userResource The user resource object (optional)
   * @return Future(UserResource)
  */
  def registerUserAsync(userResource: Option[UserResource] = None): Future[UserResource] = {
      helper.registerUser(userResource)
  }


  /**
   * Remove a tag from a user
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN
   * @param userId The id of the user 
   * @param tag The tag to remove 
   * @return void
   */
  def removeUserTag(userId: Integer, tag: String) = {
    val await = Try(Await.result(removeUserTagAsync(userId, tag), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Remove a tag from a user asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN
   * @param userId The id of the user 
   * @param tag The tag to remove 
   * @return Future(void)
  */
  def removeUserTagAsync(userId: Integer, tag: String) = {
      helper.removeUserTag(userId, tag)
  }


  /**
   * Set a user&#39;s password
   * Password should be in plain text and will be encrypted on receipt. Use SSL for security. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN or (USERS_USER and owner)
   * @param id The id of the user 
   * @param password The new plain text password (optional)
   * @return void
   */
  def setPassword(id: Integer, password: Option[StringWrapper] = None) = {
    val await = Try(Await.result(setPasswordAsync(id, password), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set a user&#39;s password asynchronously
   * Password should be in plain text and will be encrypted on receipt. Use SSL for security. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN or (USERS_USER and owner)
   * @param id The id of the user 
   * @param password The new plain text password (optional)
   * @return Future(void)
  */
  def setPasswordAsync(id: Integer, password: Option[StringWrapper] = None) = {
      helper.setPassword(id, password)
  }


  /**
   * Reset a user&#39;s password
   * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The id of the user 
   * @return void
   */
  def startPasswordReset(id: Integer) = {
    val await = Try(Await.result(startPasswordResetAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reset a user&#39;s password asynchronously
   * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The id of the user 
   * @return Future(void)
  */
  def startPasswordResetAsync(id: Integer) = {
      helper.startPasswordReset(id)
  }


  /**
   * Reset a user&#39;s password without user id
   * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param passwordReset An object containing one of three methods to look up a user (optional)
   * @return void
   */
  def submitPasswordReset(passwordReset: Option[PasswordResetRequest] = None) = {
    val await = Try(Await.result(submitPasswordResetAsync(passwordReset), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reset a user&#39;s password without user id asynchronously
   * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param passwordReset An object containing one of three methods to look up a user (optional)
   * @return Future(void)
  */
  def submitPasswordResetAsync(passwordReset: Option[PasswordResetRequest] = None) = {
      helper.submitPasswordReset(passwordReset)
  }


  /**
   * Update a user
   * Password will not be edited on this endpoint, use password specific endpoints. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN or owner
   * @param id The id of the user or &#39;me&#39; 
   * @param userResource The user resource object (optional)
   * @return void
   */
  def updateUser(id: String, userResource: Option[UserResource] = None) = {
    val await = Try(Await.result(updateUserAsync(id, userResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a user asynchronously
   * Password will not be edited on this endpoint, use password specific endpoints. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; USERS_ADMIN or owner
   * @param id The id of the user or &#39;me&#39; 
   * @param userResource The user resource object (optional)
   * @return Future(void)
  */
  def updateUserAsync(id: String, userResource: Option[UserResource] = None) = {
      helper.updateUser(id, userResource)
  }


  /**
   * Update a user template
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param userTemplateResource The user template resource object (optional)
   * @return TemplateResource
   */
  def updateUserTemplate(id: String, userTemplateResource: Option[TemplateResource] = None): Option[TemplateResource] = {
    val await = Try(Await.result(updateUserTemplateAsync(id, userTemplateResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a user template asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param userTemplateResource The user template resource object (optional)
   * @return Future(TemplateResource)
  */
  def updateUserTemplateAsync(id: String, userTemplateResource: Option[TemplateResource] = None): Future[TemplateResource] = {
      helper.updateUserTemplate(id, userTemplateResource)
  }


}

class UsersApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addUserTag(userId: Integer,
    tag: StringWrapper)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/tags")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (tag == null) throw new Exception("Missing required parameter 'tag' when calling UsersApi->addUserTag")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(tag))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserTemplate(userTemplateResource: Option[TemplateResource] = None
    )(implicit reader: ClientResponseReader[TemplateResource], writer: RequestWriter[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/users/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(userTemplateResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserTemplate(id: String,
    cascade: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersApi->deleteUserTemplate")

    cascade match {
      case Some(param) => queryParams += "cascade" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getDirectMessages1(recipientId: Integer,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceChatMessageResource]): Future[PageResourceChatMessageResource] = {
    // create path and map variables
    val path = (addFmt("/users/{recipient_id}/messages")
      replaceAll ("\\{" + "recipient_id" + "\\}",recipientId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUser(id: String)(implicit reader: ClientResponseReader[UserResource]): Future[UserResource] = {
    // create path and map variables
    val path = (addFmt("/users/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersApi->getUser")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserTags(userId: Integer)(implicit reader: ClientResponseReader[List[String]]): Future[List[String]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/tags")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserTemplate(id: String)(implicit reader: ClientResponseReader[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/users/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersApi->getUserTemplate")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserTemplates(size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceTemplateResource]): Future[PageResourceTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/users/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUsers(filterDisplayname: Option[String] = None,
    filterEmail: Option[String] = None,
    filterFirstname: Option[String] = None,
    filterFullname: Option[String] = None,
    filterLastname: Option[String] = None,
    filterUsername: Option[String] = None,
    filterTag: Option[String] = None,
    filterGroup: Option[String] = None,
    filterRole: Option[String] = None,
    filterLastActivity: Option[String] = None,
    filterIdList: Option[String] = None,
    filterSearch: Option[String] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceUserBaseResource]): Future[PageResourceUserBaseResource] = {
    // create path and map variables
    val path = (addFmt("/users"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    filterDisplayname match {
      case Some(param) => queryParams += "filter_displayname" -> param.toString
      case _ => queryParams
    }
    filterEmail match {
      case Some(param) => queryParams += "filter_email" -> param.toString
      case _ => queryParams
    }
    filterFirstname match {
      case Some(param) => queryParams += "filter_firstname" -> param.toString
      case _ => queryParams
    }
    filterFullname match {
      case Some(param) => queryParams += "filter_fullname" -> param.toString
      case _ => queryParams
    }
    filterLastname match {
      case Some(param) => queryParams += "filter_lastname" -> param.toString
      case _ => queryParams
    }
    filterUsername match {
      case Some(param) => queryParams += "filter_username" -> param.toString
      case _ => queryParams
    }
    filterTag match {
      case Some(param) => queryParams += "filter_tag" -> param.toString
      case _ => queryParams
    }
    filterGroup match {
      case Some(param) => queryParams += "filter_group" -> param.toString
      case _ => queryParams
    }
    filterRole match {
      case Some(param) => queryParams += "filter_role" -> param.toString
      case _ => queryParams
    }
    filterLastActivity match {
      case Some(param) => queryParams += "filter_last_activity" -> param.toString
      case _ => queryParams
    }
    filterIdList match {
      case Some(param) => queryParams += "filter_id_list" -> param.toString
      case _ => queryParams
    }
    filterSearch match {
      case Some(param) => queryParams += "filter_search" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def passwordReset(id: Integer,
    newPasswordRequest: Option[NewPasswordRequest] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[NewPasswordRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{id}/password-reset")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(newPasswordRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postUserMessage(recipientId: Integer,
    chatMessageRequest: Option[ChatMessageRequest] = None
    )(implicit reader: ClientResponseReader[ChatMessageResource], writer: RequestWriter[ChatMessageRequest]): Future[ChatMessageResource] = {
    // create path and map variables
    val path = (addFmt("/users/{recipient_id}/messages")
      replaceAll ("\\{" + "recipient_id" + "\\}",recipientId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(chatMessageRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def registerUser(userResource: Option[UserResource] = None
    )(implicit reader: ClientResponseReader[UserResource], writer: RequestWriter[UserResource]): Future[UserResource] = {
    // create path and map variables
    val path = (addFmt("/users"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(userResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def removeUserTag(userId: Integer,
    tag: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/tags/{tag}")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString)
      replaceAll ("\\{" + "tag" + "\\}",tag.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (tag == null) throw new Exception("Missing required parameter 'tag' when calling UsersApi->removeUserTag")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setPassword(id: Integer,
    password: Option[StringWrapper] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{id}/password")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(password))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def startPasswordReset(id: Integer)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{id}/password-reset")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def submitPasswordReset(passwordReset: Option[PasswordResetRequest] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[PasswordResetRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/password-reset"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(passwordReset))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUser(id: String,
    userResource: Option[UserResource] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[UserResource]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersApi->updateUser")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(userResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUserTemplate(id: String,
    userTemplateResource: Option[TemplateResource] = None
    )(implicit reader: ClientResponseReader[TemplateResource], writer: RequestWriter[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/users/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersApi->updateUserTemplate")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(userTemplateResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
