/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.knetikcloud.client.model

import java.text.SimpleDateFormat

import com.knetikcloud.client.model.CommentResource
import com.knetikcloud.client.model.ContributionResource
import com.knetikcloud.client.model.DispositionResource
import com.knetikcloud.client.model.FlagResource
import com.knetikcloud.client.model.IntWrapper
import com.knetikcloud.client.model.PageResourceCommentResource
import com.knetikcloud.client.model.PageResourceDispositionResource
import com.knetikcloud.client.model.PageResourceTemplateResource
import com.knetikcloud.client.model.PageResourceVideoRelationshipResource
import com.knetikcloud.client.model.PageResourceVideoResource
import com.knetikcloud.client.model.Result
import com.knetikcloud.client.model.StringWrapper
import com.knetikcloud.client.model.TemplateResource
import com.knetikcloud.client.model.VideoRelationshipResource
import com.knetikcloud.client.model.VideoResource
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

class MediaVideosApi(val defBasePath: String = "https://sandbox.knetikcloud.com",
                        defApiInvoker: ApiInvoker = ApiInvoker) {

  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS+0000")
  }
  implicit val stringReader = ClientResponseReaders.StringReader
  implicit val unitReader = ClientResponseReaders.UnitReader
  implicit val jvalueReader = ClientResponseReaders.JValueReader
  implicit val jsonReader = JsonFormatsReader
  implicit val stringWriter = RequestWriters.StringWriter
  implicit val jsonWriter = JsonFormatsWriter

  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value

  val config = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new MediaVideosApiAsyncHelper(client, config)

  /**
   * Adds a user to a video&#39;s whitelist
   * Whitelisted users can view video regardless of privacy setting. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @param userId The user id (optional)
   * @return void
   */
  def addUserToVideoWhitelist(id: Long, userId: Option[IntWrapper] = None) = {
    val await = Try(Await.result(addUserToVideoWhitelistAsync(id, userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a user to a video&#39;s whitelist asynchronously
   * Whitelisted users can view video regardless of privacy setting. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @param userId The user id (optional)
   * @return Future(void)
  */
  def addUserToVideoWhitelistAsync(id: Long, userId: Option[IntWrapper] = None) = {
      helper.addUserToVideoWhitelist(id, userId)
  }


  /**
   * Adds a new video in the system
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoResource The video object (optional)
   * @return VideoResource
   */
  def addVideo(videoResource: Option[VideoResource] = None): Option[VideoResource] = {
    val await = Try(Await.result(addVideoAsync(videoResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a new video in the system asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoResource The video object (optional)
   * @return Future(VideoResource)
  */
  def addVideoAsync(videoResource: Option[VideoResource] = None): Future[VideoResource] = {
      helper.addVideo(videoResource)
  }


  /**
   * Add a new video comment
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id  
   * @param commentResource The comment object (optional)
   * @return CommentResource
   */
  def addVideoComment(videoId: Integer, commentResource: Option[CommentResource] = None): Option[CommentResource] = {
    val await = Try(Await.result(addVideoCommentAsync(videoId, commentResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a new video comment asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id  
   * @param commentResource The comment object (optional)
   * @return Future(CommentResource)
  */
  def addVideoCommentAsync(videoId: Integer, commentResource: Option[CommentResource] = None): Future[CommentResource] = {
      helper.addVideoComment(videoId, commentResource)
  }


  /**
   * Adds a contributor to a video
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param contributionResource The contribution object (optional)
   * @return void
   */
  def addVideoContributor(videoId: Long, contributionResource: Option[ContributionResource] = None) = {
    val await = Try(Await.result(addVideoContributorAsync(videoId, contributionResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds a contributor to a video asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param contributionResource The contribution object (optional)
   * @return Future(void)
  */
  def addVideoContributorAsync(videoId: Long, contributionResource: Option[ContributionResource] = None) = {
      helper.addVideoContributor(videoId, contributionResource)
  }


  /**
   * Add a new flag
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param reason The flag reason (optional)
   * @return FlagResource
   */
  def addVideoFlag(videoId: Long, reason: Option[StringWrapper] = None): Option[FlagResource] = {
    val await = Try(Await.result(addVideoFlagAsync(videoId, reason), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a new flag asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param reason The flag reason (optional)
   * @return Future(FlagResource)
  */
  def addVideoFlagAsync(videoId: Long, reason: Option[StringWrapper] = None): Future[FlagResource] = {
      helper.addVideoFlag(videoId, reason)
  }


  /**
   * Adds one or more existing videos as related to this one
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param videoRelationshipResource The video relationship object  (optional)
   * @return VideoRelationshipResource
   */
  def addVideoRelationships(videoId: Long, videoRelationshipResource: Option[VideoRelationshipResource] = None): Option[VideoRelationshipResource] = {
    val await = Try(Await.result(addVideoRelationshipsAsync(videoId, videoRelationshipResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Adds one or more existing videos as related to this one asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param videoRelationshipResource The video relationship object  (optional)
   * @return Future(VideoRelationshipResource)
  */
  def addVideoRelationshipsAsync(videoId: Long, videoRelationshipResource: Option[VideoRelationshipResource] = None): Future[VideoRelationshipResource] = {
      helper.addVideoRelationships(videoId, videoRelationshipResource)
  }


  /**
   * Create a video disposition
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param dispositionResource The disposition object (optional)
   * @return DispositionResource
   */
  def createVideoDisposition(videoId: Integer, dispositionResource: Option[DispositionResource] = None): Option[DispositionResource] = {
    val await = Try(Await.result(createVideoDispositionAsync(videoId, dispositionResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a video disposition asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param dispositionResource The disposition object (optional)
   * @return Future(DispositionResource)
  */
  def createVideoDispositionAsync(videoId: Integer, dispositionResource: Option[DispositionResource] = None): Future[DispositionResource] = {
      helper.createVideoDisposition(videoId, dispositionResource)
  }


  /**
   * Create a video template
   * Video Templates define a type of video and the properties they have. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param videoTemplateResource The video template resource object (optional)
   * @return TemplateResource
   */
  def createVideoTemplate(videoTemplateResource: Option[TemplateResource] = None): Option[TemplateResource] = {
    val await = Try(Await.result(createVideoTemplateAsync(videoTemplateResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a video template asynchronously
   * Video Templates define a type of video and the properties they have. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param videoTemplateResource The video template resource object (optional)
   * @return Future(TemplateResource)
  */
  def createVideoTemplateAsync(videoTemplateResource: Option[TemplateResource] = None): Future[TemplateResource] = {
      helper.createVideoTemplate(videoTemplateResource)
  }


  /**
   * Deletes a video from the system if no resources are attached to it
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @return void
   */
  def deleteVideo(id: Long) = {
    val await = Try(Await.result(deleteVideoAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Deletes a video from the system if no resources are attached to it asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @return Future(void)
  */
  def deleteVideoAsync(id: Long) = {
      helper.deleteVideo(id)
  }


  /**
   * Delete a video comment
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The comment id 
   * @return void
   */
  def deleteVideoComment(videoId: Long, id: Long) = {
    val await = Try(Await.result(deleteVideoCommentAsync(videoId, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a video comment asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The comment id 
   * @return Future(void)
  */
  def deleteVideoCommentAsync(videoId: Long, id: Long) = {
      helper.deleteVideoComment(videoId, id)
  }


  /**
   * Delete a video disposition
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param dispositionId The disposition id 
   * @return void
   */
  def deleteVideoDisposition(dispositionId: Long) = {
    val await = Try(Await.result(deleteVideoDispositionAsync(dispositionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a video disposition asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param dispositionId The disposition id 
   * @return Future(void)
  */
  def deleteVideoDispositionAsync(dispositionId: Long) = {
      helper.deleteVideoDisposition(dispositionId)
  }


  /**
   * Delete a flag
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @return void
   */
  def deleteVideoFlag(videoId: Long) = {
    val await = Try(Await.result(deleteVideoFlagAsync(videoId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a flag asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @return Future(void)
  */
  def deleteVideoFlagAsync(videoId: Long) = {
      helper.deleteVideoFlag(videoId)
  }


  /**
   * Delete a video&#39;s relationship
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The relationship id 
   * @return void
   */
  def deleteVideoRelationship(videoId: Long, id: Long) = {
    val await = Try(Await.result(deleteVideoRelationshipAsync(videoId, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a video&#39;s relationship asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The relationship id 
   * @return Future(void)
  */
  def deleteVideoRelationshipAsync(videoId: Long, id: Long) = {
      helper.deleteVideoRelationship(videoId, id)
  }


  /**
   * Delete a video template
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return void
   */
  def deleteVideoTemplate(id: String, cascade: Option[String] = None) = {
    val await = Try(Await.result(deleteVideoTemplateAsync(id, cascade), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a video template asynchronously
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return Future(void)
  */
  def deleteVideoTemplateAsync(id: String, cascade: Option[String] = None) = {
      helper.deleteVideoTemplate(id, cascade)
  }


  /**
   * Get user videos
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param userId The user id 
   * @param excludeFlagged Skip videos that have been flagged by the current user (optional, default to true)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceVideoResource
   */
  def getUserVideos(userId: Integer, excludeFlagged: Option[Boolean] /* = true*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceVideoResource] = {
    val await = Try(Await.result(getUserVideosAsync(userId, excludeFlagged, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get user videos asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param userId The user id 
   * @param excludeFlagged Skip videos that have been flagged by the current user (optional, default to true)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceVideoResource)
  */
  def getUserVideosAsync(userId: Integer, excludeFlagged: Option[Boolean] /* = true*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceVideoResource] = {
      helper.getUserVideos(userId, excludeFlagged, size, page)
  }


  /**
   * Loads a specific video details
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @return VideoResource
   */
  def getVideo(id: Long): Option[VideoResource] = {
    val await = Try(Await.result(getVideoAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Loads a specific video details asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @return Future(VideoResource)
  */
  def getVideoAsync(id: Long): Future[VideoResource] = {
      helper.getVideo(id)
  }


  /**
   * Returns a page of comments for a video
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param videoId The video id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceCommentResource
   */
  def getVideoComments(videoId: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceCommentResource] = {
    val await = Try(Await.result(getVideoCommentsAsync(videoId, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns a page of comments for a video asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param videoId The video id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceCommentResource)
  */
  def getVideoCommentsAsync(videoId: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceCommentResource] = {
      helper.getVideoComments(videoId, size, page)
  }


  /**
   * Returns a page of dispositions for a video
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param videoId The video id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceDispositionResource
   */
  def getVideoDispositions(videoId: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceDispositionResource] = {
    val await = Try(Await.result(getVideoDispositionsAsync(videoId, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns a page of dispositions for a video asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param videoId The video id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceDispositionResource)
  */
  def getVideoDispositionsAsync(videoId: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceDispositionResource] = {
      helper.getVideoDispositions(videoId, size, page)
  }


  /**
   * Returns a page of video relationships
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param videoId The video id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceVideoRelationshipResource
   */
  def getVideoRelationships(videoId: Long, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceVideoRelationshipResource] = {
    val await = Try(Await.result(getVideoRelationshipsAsync(videoId, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns a page of video relationships asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param videoId The video id 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceVideoRelationshipResource)
  */
  def getVideoRelationshipsAsync(videoId: Long, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceVideoRelationshipResource] = {
      helper.getVideoRelationships(videoId, size, page)
  }


  /**
   * Get a single video template
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or VIDEOS_ADMIN
   * @param id The id of the template 
   * @return TemplateResource
   */
  def getVideoTemplate(id: String): Option[TemplateResource] = {
    val await = Try(Await.result(getVideoTemplateAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a single video template asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or VIDEOS_ADMIN
   * @param id The id of the template 
   * @return Future(TemplateResource)
  */
  def getVideoTemplateAsync(id: String): Future[TemplateResource] = {
      helper.getVideoTemplate(id)
  }


  /**
   * List and search video templates
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or VIDEOS_ADMIN
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceTemplateResource
   */
  def getVideoTemplates(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceTemplateResource] = {
    val await = Try(Await.result(getVideoTemplatesAsync(size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search video templates asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN or VIDEOS_ADMIN
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceTemplateResource)
  */
  def getVideoTemplatesAsync(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceTemplateResource] = {
      helper.getVideoTemplates(size, page, order)
  }


  /**
   * Search videos using the documented filters
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param excludeFlagged Skip videos that have been flagged by the current user (optional, default to true)
   * @param filterVideosByUploader Filter for videos by uploader id (optional)
   * @param filterCategory Filter for videos from a specific category by id (optional)
   * @param filterTagset Filter for videos with specified tags (separated by comma) (optional)
   * @param filterVideosByName Filter for videos which name *STARTS* with the given string (optional)
   * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID (optional)
   * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID (optional)
   * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false (optional)
   * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false (optional)
   * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well (optional)
   * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission) (optional)
   * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to author:ASC)
   * @return PageResourceVideoResource
   */
  def getVideos(excludeFlagged: Option[Boolean] /* = true*/, filterVideosByUploader: Option[Integer] = None, filterCategory: Option[String] = None, filterTagset: Option[String] = None, filterVideosByName: Option[String] = None, filterVideosByContributor: Option[Integer] = None, filterVideosByAuthor: Option[Integer] = None, filterHasAuthor: Option[Boolean] = None, filterHasUploader: Option[Boolean] = None, filterRelatedTo: Option[String] = None, filterFriends: Option[Boolean] = None, filterDisposition: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = author:ASC*/): Option[PageResourceVideoResource] = {
    val await = Try(Await.result(getVideosAsync(excludeFlagged, filterVideosByUploader, filterCategory, filterTagset, filterVideosByName, filterVideosByContributor, filterVideosByAuthor, filterHasAuthor, filterHasUploader, filterRelatedTo, filterFriends, filterDisposition, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Search videos using the documented filters asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param excludeFlagged Skip videos that have been flagged by the current user (optional, default to true)
   * @param filterVideosByUploader Filter for videos by uploader id (optional)
   * @param filterCategory Filter for videos from a specific category by id (optional)
   * @param filterTagset Filter for videos with specified tags (separated by comma) (optional)
   * @param filterVideosByName Filter for videos which name *STARTS* with the given string (optional)
   * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID (optional)
   * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID (optional)
   * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false (optional)
   * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false (optional)
   * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well (optional)
   * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission) (optional)
   * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to author:ASC)
   * @return Future(PageResourceVideoResource)
  */
  def getVideosAsync(excludeFlagged: Option[Boolean] /* = true*/, filterVideosByUploader: Option[Integer] = None, filterCategory: Option[String] = None, filterTagset: Option[String] = None, filterVideosByName: Option[String] = None, filterVideosByContributor: Option[Integer] = None, filterVideosByAuthor: Option[Integer] = None, filterHasAuthor: Option[Boolean] = None, filterHasUploader: Option[Boolean] = None, filterRelatedTo: Option[String] = None, filterFriends: Option[Boolean] = None, filterDisposition: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = author:ASC*/): Future[PageResourceVideoResource] = {
      helper.getVideos(excludeFlagged, filterVideosByUploader, filterCategory, filterTagset, filterVideosByName, filterVideosByContributor, filterVideosByAuthor, filterHasAuthor, filterHasUploader, filterRelatedTo, filterFriends, filterDisposition, size, page, order)
  }


  /**
   * Removes a user from a video&#39;s whitelist
   * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The user id 
   * @return void
   */
  def removeUserFromVideoWhitelist(videoId: Long, id: Integer) = {
    val await = Try(Await.result(removeUserFromVideoWhitelistAsync(videoId, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Removes a user from a video&#39;s whitelist asynchronously
   * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting. &lt;br&gt;&lt;br&gt;&lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The user id 
   * @return Future(void)
  */
  def removeUserFromVideoWhitelistAsync(videoId: Long, id: Integer) = {
      helper.removeUserFromVideoWhitelist(videoId, id)
  }


  /**
   * Removes a contributor from a video
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The contributor id 
   * @return void
   */
  def removeVideoContributor(videoId: Long, id: Integer) = {
    val await = Try(Await.result(removeVideoContributorAsync(videoId, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Removes a contributor from a video asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The contributor id 
   * @return Future(void)
  */
  def removeVideoContributorAsync(videoId: Long, id: Integer) = {
      helper.removeVideoContributor(videoId, id)
  }


  /**
   * Modifies a video&#39;s details
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @param videoResource The video object (optional)
   * @return void
   */
  def updateVideo(id: Long, videoResource: Option[VideoResource] = None) = {
    val await = Try(Await.result(updateVideoAsync(id, videoResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Modifies a video&#39;s details asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param id The video id 
   * @param videoResource The video object (optional)
   * @return Future(void)
  */
  def updateVideoAsync(id: Long, videoResource: Option[VideoResource] = None) = {
      helper.updateVideo(id, videoResource)
  }


  /**
   * Update a video comment
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The comment id 
   * @param content The comment content (optional)
   * @return void
   */
  def updateVideoComment(videoId: Long, id: Long, content: Option[StringWrapper] = None) = {
    val await = Try(Await.result(updateVideoCommentAsync(videoId, id, content), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a video comment asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param id The comment id 
   * @param content The comment content (optional)
   * @return Future(void)
  */
  def updateVideoCommentAsync(videoId: Long, id: Long, content: Option[StringWrapper] = None) = {
      helper.updateVideoComment(videoId, id, content)
  }


  /**
   * Update a video&#39;s relationship details
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param relationshipId The relationship id 
   * @param details The video relationship details (optional)
   * @return void
   */
  def updateVideoRelationship(videoId: Long, relationshipId: Long, details: Option[StringWrapper] = None) = {
    val await = Try(Await.result(updateVideoRelationshipAsync(videoId, relationshipId, details), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a video&#39;s relationship details asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; VIDEOS_USER or VIDEOS_ADMIN
   * @param videoId The video id 
   * @param relationshipId The relationship id 
   * @param details The video relationship details (optional)
   * @return Future(void)
  */
  def updateVideoRelationshipAsync(videoId: Long, relationshipId: Long, details: Option[StringWrapper] = None) = {
      helper.updateVideoRelationship(videoId, relationshipId, details)
  }


  /**
   * Update a video template
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param videoTemplateResource The video template resource object (optional)
   * @return TemplateResource
   */
  def updateVideoTemplate(id: String, videoTemplateResource: Option[TemplateResource] = None): Option[TemplateResource] = {
    val await = Try(Await.result(updateVideoTemplateAsync(id, videoTemplateResource), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a video template asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; TEMPLATE_ADMIN
   * @param id The id of the template 
   * @param videoTemplateResource The video template resource object (optional)
   * @return Future(TemplateResource)
  */
  def updateVideoTemplateAsync(id: String, videoTemplateResource: Option[TemplateResource] = None): Future[TemplateResource] = {
      helper.updateVideoTemplate(id, videoTemplateResource)
  }


  /**
   * Increment a video&#39;s view count
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The video id 
   * @return void
   */
  def viewVideo(id: Long) = {
    val await = Try(Await.result(viewVideoAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Increment a video&#39;s view count asynchronously
   * &lt;b&gt;Permissions Needed:&lt;/b&gt; ANY
   * @param id The video id 
   * @return Future(void)
  */
  def viewVideoAsync(id: Long) = {
      helper.viewVideo(id)
  }


}

class MediaVideosApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addUserToVideoWhitelist(id: Long,
    userId: Option[IntWrapper] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[IntWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{id}/whitelist")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(userId))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addVideo(videoResource: Option[VideoResource] = None
    )(implicit reader: ClientResponseReader[VideoResource], writer: RequestWriter[VideoResource]): Future[VideoResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(videoResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addVideoComment(videoId: Integer,
    commentResource: Option[CommentResource] = None
    )(implicit reader: ClientResponseReader[CommentResource], writer: RequestWriter[CommentResource]): Future[CommentResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/comments")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(commentResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addVideoContributor(videoId: Long,
    contributionResource: Option[ContributionResource] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[ContributionResource]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/contributors")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(contributionResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addVideoFlag(videoId: Long,
    reason: Option[StringWrapper] = None
    )(implicit reader: ClientResponseReader[FlagResource], writer: RequestWriter[StringWrapper]): Future[FlagResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/moderation")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(reason))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def addVideoRelationships(videoId: Long,
    videoRelationshipResource: Option[VideoRelationshipResource] = None
    )(implicit reader: ClientResponseReader[VideoRelationshipResource], writer: RequestWriter[VideoRelationshipResource]): Future[VideoRelationshipResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/related")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(videoRelationshipResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createVideoDisposition(videoId: Integer,
    dispositionResource: Option[DispositionResource] = None
    )(implicit reader: ClientResponseReader[DispositionResource], writer: RequestWriter[DispositionResource]): Future[DispositionResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/dispositions")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(dispositionResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createVideoTemplate(videoTemplateResource: Option[TemplateResource] = None
    )(implicit reader: ClientResponseReader[TemplateResource], writer: RequestWriter[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(videoTemplateResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteVideo(id: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteVideoComment(videoId: Long,
    id: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/comments/{id}")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteVideoDisposition(dispositionId: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/dispositions/{disposition_id}")
      replaceAll ("\\{" + "disposition_id" + "\\}",dispositionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteVideoFlag(videoId: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/moderation")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteVideoRelationship(videoId: Long,
    id: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/related/{id}")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteVideoTemplate(id: String,
    cascade: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling MediaVideosApi->deleteVideoTemplate")

    cascade match {
      case Some(param) => queryParams += "cascade" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserVideos(userId: Integer,
    excludeFlagged: Option[Boolean] = Some(true),
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceVideoResource]): Future[PageResourceVideoResource] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/videos")
      replaceAll ("\\{" + "user_id" + "\\}",userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    excludeFlagged match {
      case Some(param) => queryParams += "exclude_flagged" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideo(id: Long)(implicit reader: ClientResponseReader[VideoResource]): Future[VideoResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideoComments(videoId: Integer,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceCommentResource]): Future[PageResourceCommentResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/comments")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideoDispositions(videoId: Integer,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceDispositionResource]): Future[PageResourceDispositionResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/dispositions")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideoRelationships(videoId: Long,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceVideoRelationshipResource]): Future[PageResourceVideoRelationshipResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/related")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideoTemplate(id: String)(implicit reader: ClientResponseReader[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling MediaVideosApi->getVideoTemplate")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideoTemplates(size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceTemplateResource]): Future[PageResourceTemplateResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/templates"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getVideos(excludeFlagged: Option[Boolean] = Some(true),
    filterVideosByUploader: Option[Integer] = None,
    filterCategory: Option[String] = None,
    filterTagset: Option[String] = None,
    filterVideosByName: Option[String] = None,
    filterVideosByContributor: Option[Integer] = None,
    filterVideosByAuthor: Option[Integer] = None,
    filterHasAuthor: Option[Boolean] = None,
    filterHasUploader: Option[Boolean] = None,
    filterRelatedTo: Option[String] = None,
    filterFriends: Option[Boolean] = None,
    filterDisposition: Option[String] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(author:ASC)
    )(implicit reader: ClientResponseReader[PageResourceVideoResource]): Future[PageResourceVideoResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    excludeFlagged match {
      case Some(param) => queryParams += "exclude_flagged" -> param.toString
      case _ => queryParams
    }
    filterVideosByUploader match {
      case Some(param) => queryParams += "filter_videos_by_uploader" -> param.toString
      case _ => queryParams
    }
    filterCategory match {
      case Some(param) => queryParams += "filter_category" -> param.toString
      case _ => queryParams
    }
    filterTagset match {
      case Some(param) => queryParams += "filter_tagset" -> param.toString
      case _ => queryParams
    }
    filterVideosByName match {
      case Some(param) => queryParams += "filter_videos_by_name" -> param.toString
      case _ => queryParams
    }
    filterVideosByContributor match {
      case Some(param) => queryParams += "filter_videos_by_contributor" -> param.toString
      case _ => queryParams
    }
    filterVideosByAuthor match {
      case Some(param) => queryParams += "filter_videos_by_author" -> param.toString
      case _ => queryParams
    }
    filterHasAuthor match {
      case Some(param) => queryParams += "filter_has_author" -> param.toString
      case _ => queryParams
    }
    filterHasUploader match {
      case Some(param) => queryParams += "filter_has_uploader" -> param.toString
      case _ => queryParams
    }
    filterRelatedTo match {
      case Some(param) => queryParams += "filter_related_to" -> param.toString
      case _ => queryParams
    }
    filterFriends match {
      case Some(param) => queryParams += "filter_friends" -> param.toString
      case _ => queryParams
    }
    filterDisposition match {
      case Some(param) => queryParams += "filter_disposition" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def removeUserFromVideoWhitelist(videoId: Long,
    id: Integer)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/whitelist/{id}")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def removeVideoContributor(videoId: Long,
    id: Integer)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/contributors/{id}")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateVideo(id: Long,
    videoResource: Option[VideoResource] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[VideoResource]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(videoResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateVideoComment(videoId: Long,
    id: Long,
    content: Option[StringWrapper] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/comments/{id}/content")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString)
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(content))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateVideoRelationship(videoId: Long,
    relationshipId: Long,
    details: Option[StringWrapper] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{video_id}/related/{id}/relationship_details")
      replaceAll ("\\{" + "video_id" + "\\}",videoId.toString)
      replaceAll ("\\{" + "relationship_id" + "\\}",relationshipId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(details))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateVideoTemplate(id: String,
    videoTemplateResource: Option[TemplateResource] = None
    )(implicit reader: ClientResponseReader[TemplateResource], writer: RequestWriter[TemplateResource]): Future[TemplateResource] = {
    // create path and map variables
    val path = (addFmt("/media/videos/templates/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling MediaVideosApi->updateVideoTemplate")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(videoTemplateResource))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def viewVideo(id: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/media/videos/{id}/views")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
