/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.knetikcloud.client.model

import java.text.SimpleDateFormat

import com.knetikcloud.client.model.PageResourceTransactionResource
import com.knetikcloud.client.model.RefundRequest
import com.knetikcloud.client.model.RefundResource
import com.knetikcloud.client.model.Result
import com.knetikcloud.client.model.TransactionResource
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

class PaymentsTransactionsApi(val defBasePath: String = "https://devsandbox.knetikcloud.com",
                        defApiInvoker: ApiInvoker = ApiInvoker) {

  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS+0000")
  }
  implicit val stringReader = ClientResponseReaders.StringReader
  implicit val unitReader = ClientResponseReaders.UnitReader
  implicit val jvalueReader = ClientResponseReaders.JValueReader
  implicit val jsonReader = JsonFormatsReader
  implicit val stringWriter = RequestWriters.StringWriter
  implicit val jsonWriter = JsonFormatsWriter

  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value

  val config = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new PaymentsTransactionsApiAsyncHelper(client, config)

  /**
   * Get the details for a single transaction
   * 
   * @param id id 
   * @return TransactionResource
   */
  def getTransaction(id: Integer): Option[TransactionResource] = {
    val await = Try(Await.result(getTransactionAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the details for a single transaction asynchronously
   * 
   * @param id id 
   * @return Future(TransactionResource)
  */
  def getTransactionAsync(id: Integer): Future[TransactionResource] = {
      helper.getTransaction(id)
  }


  /**
   * List and search transactions
   * 
   * @param filterInvoice Filter for transactions from a specific invoice (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceTransactionResource
   */
  def getTransactions(filterInvoice: Option[Integer] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceTransactionResource] = {
    val await = Try(Await.result(getTransactionsAsync(filterInvoice, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List and search transactions asynchronously
   * 
   * @param filterInvoice Filter for transactions from a specific invoice (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return Future(PageResourceTransactionResource)
  */
  def getTransactionsAsync(filterInvoice: Option[Integer] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Future[PageResourceTransactionResource] = {
      helper.getTransactions(filterInvoice, size, page, order)
  }


  /**
   * Refund a payment transaction, in full or in part
   * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
   * @param id The id of the transaction to refund 
   * @param request Request containing refund details (optional)
   * @return RefundResource
   */
  def refundTransaction(id: Integer, request: Option[RefundRequest] = None): Option[RefundResource] = {
    val await = Try(Await.result(refundTransactionAsync(id, request), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Refund a payment transaction, in full or in part asynchronously
   * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
   * @param id The id of the transaction to refund 
   * @param request Request containing refund details (optional)
   * @return Future(RefundResource)
  */
  def refundTransactionAsync(id: Integer, request: Option[RefundRequest] = None): Future[RefundResource] = {
      helper.refundTransaction(id, request)
  }


}

class PaymentsTransactionsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def getTransaction(id: Integer)(implicit reader: ClientResponseReader[TransactionResource]): Future[TransactionResource] = {
    // create path and map variables
    val path = (addFmt("/transactions/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTransactions(filterInvoice: Option[Integer] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(id:ASC)
    )(implicit reader: ClientResponseReader[PageResourceTransactionResource]): Future[PageResourceTransactionResource] = {
    // create path and map variables
    val path = (addFmt("/transactions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    filterInvoice match {
      case Some(param) => queryParams += "filter_invoice" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def refundTransaction(id: Integer,
    request: Option[RefundRequest] = None
    )(implicit reader: ClientResponseReader[RefundResource], writer: RequestWriter[RefundRequest]): Future[RefundResource] = {
    // create path and map variables
    val path = (addFmt("/transactions/{id}/refunds")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(request))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
