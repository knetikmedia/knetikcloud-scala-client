/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.knetikcloud.client.model

import java.text.SimpleDateFormat

import com.knetikcloud.client.model.AddressResource
import com.knetikcloud.client.model.InvoiceCreateRequest
import com.knetikcloud.client.model.InvoicePaymentStatusRequest
import com.knetikcloud.client.model.InvoiceResource
import com.knetikcloud.client.model.PageResourceInvoiceLogEntry
import com.knetikcloud.client.model.PageResourceInvoiceResource
import com.knetikcloud.client.model.PayBySavedMethodRequest
import com.knetikcloud.client.model.Result
import com.knetikcloud.client.model.StringWrapper
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

class InvoicesApi(val defBasePath: String = "https://sandbox.knetikcloud.com",
                        defApiInvoker: ApiInvoker = ApiInvoker) {

  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS+0000")
  }
  implicit val stringReader = ClientResponseReaders.StringReader
  implicit val unitReader = ClientResponseReaders.UnitReader
  implicit val jvalueReader = ClientResponseReaders.JValueReader
  implicit val jsonReader = JsonFormatsReader
  implicit val stringWriter = RequestWriters.StringWriter
  implicit val jsonWriter = JsonFormatsWriter

  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value

  val config = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new InvoicesApiAsyncHelper(client, config)

  /**
   * Create an invoice
   * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
   * @param req Invoice to be created (optional)
   * @return List[InvoiceResource]
   */
  def createInvoice(req: Option[InvoiceCreateRequest] = None): Option[List[InvoiceResource]] = {
    val await = Try(Await.result(createInvoiceAsync(req), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create an invoice asynchronously
   * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
   * @param req Invoice to be created (optional)
   * @return Future(List[InvoiceResource])
  */
  def createInvoiceAsync(req: Option[InvoiceCreateRequest] = None): Future[List[InvoiceResource]] = {
      helper.createInvoice(req)
  }


  /**
   * Lists available fulfillment statuses
   * 
   * @return List[String]
   */
  def getFulFillmentStatuses(): Option[List[String]] = {
    val await = Try(Await.result(getFulFillmentStatusesAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Lists available fulfillment statuses asynchronously
   * 
   * @return Future(List[String])
  */
  def getFulFillmentStatusesAsync(): Future[List[String]] = {
      helper.getFulFillmentStatuses()
  }


  /**
   * Retrieve an invoice
   * 
   * @param id The id of the invoice 
   * @return InvoiceResource
   */
  def getInvoice(id: Integer): Option[InvoiceResource] = {
    val await = Try(Await.result(getInvoiceAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve an invoice asynchronously
   * 
   * @param id The id of the invoice 
   * @return Future(InvoiceResource)
  */
  def getInvoiceAsync(id: Integer): Future[InvoiceResource] = {
      helper.getInvoice(id)
  }


  /**
   * List invoice logs
   * 
   * @param id The id of the invoice 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceInvoiceLogEntry
   */
  def getInvoiceLogs(id: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceInvoiceLogEntry] = {
    val await = Try(Await.result(getInvoiceLogsAsync(id, size, page), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List invoice logs asynchronously
   * 
   * @param id The id of the invoice 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return Future(PageResourceInvoiceLogEntry)
  */
  def getInvoiceLogsAsync(id: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Future[PageResourceInvoiceLogEntry] = {
      helper.getInvoiceLogs(id, size, page)
  }


  /**
   * Retrieve invoices
   * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
   * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions. (optional)
   * @param filterEmail Filters invoices by customer&#39;s email. Admins only. (optional)
   * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses (optional)
   * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses (optional)
   * @param filterItemName Filters invoices by item name containing the given string (optional)
   * @param filterExternalRef Filters invoices by external reference. (optional)
   * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874 (optional)
   * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list (optional)
   * @param filterCurrency Filters invoices by currency. ISO3 currency code (optional)
   * @param filterShippingStateName Filters invoices by shipping address: Exact match state name (optional)
   * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name (optional)
   * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54 (optional)
   * @param filterVendorName Filters invoices by vendor name starting with given string (optional)
   * @param filterSku Filters invoices by item sku (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to 1)
   * @return PageResourceInvoiceResource
   */
  def getInvoices(filterUser: Option[Integer] = None, filterEmail: Option[String] = None, filterFulfillmentStatus: Option[String] = None, filterPaymentStatus: Option[String] = None, filterItemName: Option[String] = None, filterExternalRef: Option[String] = None, filterCreatedDate: Option[String] = None, filterVendorIds: Option[String] = None, filterCurrency: Option[String] = None, filterShippingStateName: Option[String] = None, filterShippingCountryName: Option[String] = None, filterShipping: Option[String] = None, filterVendorName: Option[String] = None, filterSku: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = 1*/): Option[PageResourceInvoiceResource] = {
    val await = Try(Await.result(getInvoicesAsync(filterUser, filterEmail, filterFulfillmentStatus, filterPaymentStatus, filterItemName, filterExternalRef, filterCreatedDate, filterVendorIds, filterCurrency, filterShippingStateName, filterShippingCountryName, filterShipping, filterVendorName, filterSku, size, page, order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve invoices asynchronously
   * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
   * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions. (optional)
   * @param filterEmail Filters invoices by customer&#39;s email. Admins only. (optional)
   * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses (optional)
   * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses (optional)
   * @param filterItemName Filters invoices by item name containing the given string (optional)
   * @param filterExternalRef Filters invoices by external reference. (optional)
   * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874 (optional)
   * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list (optional)
   * @param filterCurrency Filters invoices by currency. ISO3 currency code (optional)
   * @param filterShippingStateName Filters invoices by shipping address: Exact match state name (optional)
   * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name (optional)
   * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54 (optional)
   * @param filterVendorName Filters invoices by vendor name starting with given string (optional)
   * @param filterSku Filters invoices by item sku (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to 1)
   * @return Future(PageResourceInvoiceResource)
  */
  def getInvoicesAsync(filterUser: Option[Integer] = None, filterEmail: Option[String] = None, filterFulfillmentStatus: Option[String] = None, filterPaymentStatus: Option[String] = None, filterItemName: Option[String] = None, filterExternalRef: Option[String] = None, filterCreatedDate: Option[String] = None, filterVendorIds: Option[String] = None, filterCurrency: Option[String] = None, filterShippingStateName: Option[String] = None, filterShippingCountryName: Option[String] = None, filterShipping: Option[String] = None, filterVendorName: Option[String] = None, filterSku: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = 1*/): Future[PageResourceInvoiceResource] = {
      helper.getInvoices(filterUser, filterEmail, filterFulfillmentStatus, filterPaymentStatus, filterItemName, filterExternalRef, filterCreatedDate, filterVendorIds, filterCurrency, filterShippingStateName, filterShippingCountryName, filterShipping, filterVendorName, filterSku, size, page, order)
  }


  /**
   * Lists available payment statuses
   * 
   * @return List[String]
   */
  def getPaymentStatuses(): Option[List[String]] = {
    val await = Try(Await.result(getPaymentStatusesAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Lists available payment statuses asynchronously
   * 
   * @return Future(List[String])
  */
  def getPaymentStatusesAsync(): Future[List[String]] = {
      helper.getPaymentStatuses()
  }


  /**
   * Pay an invoice using a saved payment method
   * 
   * @param id The id of the invoice 
   * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited. (optional)
   * @return void
   */
  def payInvoice(id: Integer, request: Option[PayBySavedMethodRequest] = None) = {
    val await = Try(Await.result(payInvoiceAsync(id, request), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Pay an invoice using a saved payment method asynchronously
   * 
   * @param id The id of the invoice 
   * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited. (optional)
   * @return Future(void)
  */
  def payInvoiceAsync(id: Integer, request: Option[PayBySavedMethodRequest] = None) = {
      helper.payInvoice(id, request)
  }


  /**
   * Set the fulfillment status of a bundled invoice item
   * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
   * @param id The id of the invoice 
   * @param bundleSku The sku of the bundle in the invoice that contains the given target 
   * @param sku The sku of an item in the bundle in the invoice 
   * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39; 
   * @return void
   */
  def setBundledInvoiceItemFulfillmentStatus(id: Integer, bundleSku: String, sku: String, status: StringWrapper) = {
    val await = Try(Await.result(setBundledInvoiceItemFulfillmentStatusAsync(id, bundleSku, sku, status), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the fulfillment status of a bundled invoice item asynchronously
   * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
   * @param id The id of the invoice 
   * @param bundleSku The sku of the bundle in the invoice that contains the given target 
   * @param sku The sku of an item in the bundle in the invoice 
   * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39; 
   * @return Future(void)
  */
  def setBundledInvoiceItemFulfillmentStatusAsync(id: Integer, bundleSku: String, sku: String, status: StringWrapper) = {
      helper.setBundledInvoiceItemFulfillmentStatus(id, bundleSku, sku, status)
  }


  /**
   * Set the external reference of an invoice
   * 
   * @param id The id of the invoice 
   * @param externalRef External reference info (optional)
   * @return void
   */
  def setExternalRef(id: Integer, externalRef: Option[StringWrapper] = None) = {
    val await = Try(Await.result(setExternalRefAsync(id, externalRef), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the external reference of an invoice asynchronously
   * 
   * @param id The id of the invoice 
   * @param externalRef External reference info (optional)
   * @return Future(void)
  */
  def setExternalRefAsync(id: Integer, externalRef: Option[StringWrapper] = None) = {
      helper.setExternalRef(id, externalRef)
  }


  /**
   * Set the fulfillment status of an invoice item
   * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
   * @param id The id of the invoice 
   * @param sku The sku of an item in the invoice 
   * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39; 
   * @return void
   */
  def setInvoiceItemFulfillmentStatus(id: Integer, sku: String, status: StringWrapper) = {
    val await = Try(Await.result(setInvoiceItemFulfillmentStatusAsync(id, sku, status), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the fulfillment status of an invoice item asynchronously
   * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
   * @param id The id of the invoice 
   * @param sku The sku of an item in the invoice 
   * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39; 
   * @return Future(void)
  */
  def setInvoiceItemFulfillmentStatusAsync(id: Integer, sku: String, status: StringWrapper) = {
      helper.setInvoiceItemFulfillmentStatus(id, sku, status)
  }


  /**
   * Set the order notes of an invoice
   * 
   * @param id The id of the invoice 
   * @param orderNotes Payment status info (optional)
   * @return void
   */
  def setOrderNotes(id: Integer, orderNotes: Option[StringWrapper] = None) = {
    val await = Try(Await.result(setOrderNotesAsync(id, orderNotes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the order notes of an invoice asynchronously
   * 
   * @param id The id of the invoice 
   * @param orderNotes Payment status info (optional)
   * @return Future(void)
  */
  def setOrderNotesAsync(id: Integer, orderNotes: Option[StringWrapper] = None) = {
      helper.setOrderNotes(id, orderNotes)
  }


  /**
   * Set the payment status of an invoice
   * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
   * @param id The id of the invoice 
   * @param request Payment status info (optional)
   * @return void
   */
  def setPaymentStatus(id: Integer, request: Option[InvoicePaymentStatusRequest] = None) = {
    val await = Try(Await.result(setPaymentStatusAsync(id, request), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set the payment status of an invoice asynchronously
   * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
   * @param id The id of the invoice 
   * @param request Payment status info (optional)
   * @return Future(void)
  */
  def setPaymentStatusAsync(id: Integer, request: Option[InvoicePaymentStatusRequest] = None) = {
      helper.setPaymentStatus(id, request)
  }


  /**
   * Set or update billing info
   * 
   * @param id The id of the invoice 
   * @param billingInfoRequest Address info (optional)
   * @return void
   */
  def updateBillingInfo(id: Integer, billingInfoRequest: Option[AddressResource] = None) = {
    val await = Try(Await.result(updateBillingInfoAsync(id, billingInfoRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set or update billing info asynchronously
   * 
   * @param id The id of the invoice 
   * @param billingInfoRequest Address info (optional)
   * @return Future(void)
  */
  def updateBillingInfoAsync(id: Integer, billingInfoRequest: Option[AddressResource] = None) = {
      helper.updateBillingInfo(id, billingInfoRequest)
  }


}

class InvoicesApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def createInvoice(req: Option[InvoiceCreateRequest] = None
    )(implicit reader: ClientResponseReader[List[InvoiceResource]], writer: RequestWriter[InvoiceCreateRequest]): Future[List[InvoiceResource]] = {
    // create path and map variables
    val path = (addFmt("/invoices"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(req))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getFulFillmentStatuses()(implicit reader: ClientResponseReader[List[String]]): Future[List[String]] = {
    // create path and map variables
    val path = (addFmt("/invoices/fulfillment-statuses"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getInvoice(id: Integer)(implicit reader: ClientResponseReader[InvoiceResource]): Future[InvoiceResource] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getInvoiceLogs(id: Integer,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceInvoiceLogEntry]): Future[PageResourceInvoiceLogEntry] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/logs")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getInvoices(filterUser: Option[Integer] = None,
    filterEmail: Option[String] = None,
    filterFulfillmentStatus: Option[String] = None,
    filterPaymentStatus: Option[String] = None,
    filterItemName: Option[String] = None,
    filterExternalRef: Option[String] = None,
    filterCreatedDate: Option[String] = None,
    filterVendorIds: Option[String] = None,
    filterCurrency: Option[String] = None,
    filterShippingStateName: Option[String] = None,
    filterShippingCountryName: Option[String] = None,
    filterShipping: Option[String] = None,
    filterVendorName: Option[String] = None,
    filterSku: Option[String] = None,
    size: Option[Integer] = Some(25),
    page: Option[Integer] = Some(1),
    order: Option[String] = Some(1)
    )(implicit reader: ClientResponseReader[PageResourceInvoiceResource]): Future[PageResourceInvoiceResource] = {
    // create path and map variables
    val path = (addFmt("/invoices"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    filterUser match {
      case Some(param) => queryParams += "filter_user" -> param.toString
      case _ => queryParams
    }
    filterEmail match {
      case Some(param) => queryParams += "filter_email" -> param.toString
      case _ => queryParams
    }
    filterFulfillmentStatus match {
      case Some(param) => queryParams += "filter_fulfillment_status" -> param.toString
      case _ => queryParams
    }
    filterPaymentStatus match {
      case Some(param) => queryParams += "filter_payment_status" -> param.toString
      case _ => queryParams
    }
    filterItemName match {
      case Some(param) => queryParams += "filter_item_name" -> param.toString
      case _ => queryParams
    }
    filterExternalRef match {
      case Some(param) => queryParams += "filter_external_ref" -> param.toString
      case _ => queryParams
    }
    filterCreatedDate match {
      case Some(param) => queryParams += "filter_created_date" -> param.toString
      case _ => queryParams
    }
    filterVendorIds match {
      case Some(param) => queryParams += "filter_vendor_ids" -> param.toString
      case _ => queryParams
    }
    filterCurrency match {
      case Some(param) => queryParams += "filter_currency" -> param.toString
      case _ => queryParams
    }
    filterShippingStateName match {
      case Some(param) => queryParams += "filter_shipping_state_name" -> param.toString
      case _ => queryParams
    }
    filterShippingCountryName match {
      case Some(param) => queryParams += "filter_shipping_country_name" -> param.toString
      case _ => queryParams
    }
    filterShipping match {
      case Some(param) => queryParams += "filter_shipping" -> param.toString
      case _ => queryParams
    }
    filterVendorName match {
      case Some(param) => queryParams += "filter_vendor_name" -> param.toString
      case _ => queryParams
    }
    filterSku match {
      case Some(param) => queryParams += "filter_sku" -> param.toString
      case _ => queryParams
    }
    size match {
      case Some(param) => queryParams += "size" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    order match {
      case Some(param) => queryParams += "order" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getPaymentStatuses()(implicit reader: ClientResponseReader[List[String]]): Future[List[String]] = {
    // create path and map variables
    val path = (addFmt("/invoices/payment-statuses"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def payInvoice(id: Integer,
    request: Option[PayBySavedMethodRequest] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[PayBySavedMethodRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/payments")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(request))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setBundledInvoiceItemFulfillmentStatus(id: Integer,
    bundleSku: String,
    sku: String,
    status: StringWrapper)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/items/{bundleSku}/bundled-skus/{sku}/fulfillment-status")
      replaceAll ("\\{" + "id" + "\\}",id.toString)
      replaceAll ("\\{" + "bundleSku" + "\\}",bundleSku.toString)
      replaceAll ("\\{" + "sku" + "\\}",sku.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (bundleSku == null) throw new Exception("Missing required parameter 'bundleSku' when calling InvoicesApi->setBundledInvoiceItemFulfillmentStatus")

    if (sku == null) throw new Exception("Missing required parameter 'sku' when calling InvoicesApi->setBundledInvoiceItemFulfillmentStatus")

    if (status == null) throw new Exception("Missing required parameter 'status' when calling InvoicesApi->setBundledInvoiceItemFulfillmentStatus")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(status))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setExternalRef(id: Integer,
    externalRef: Option[StringWrapper] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/external-ref")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(externalRef))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setInvoiceItemFulfillmentStatus(id: Integer,
    sku: String,
    status: StringWrapper)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/items/{sku}/fulfillment-status")
      replaceAll ("\\{" + "id" + "\\}",id.toString)
      replaceAll ("\\{" + "sku" + "\\}",sku.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (sku == null) throw new Exception("Missing required parameter 'sku' when calling InvoicesApi->setInvoiceItemFulfillmentStatus")

    if (status == null) throw new Exception("Missing required parameter 'status' when calling InvoicesApi->setInvoiceItemFulfillmentStatus")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(status))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setOrderNotes(id: Integer,
    orderNotes: Option[StringWrapper] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StringWrapper]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/order-notes")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(orderNotes))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setPaymentStatus(id: Integer,
    request: Option[InvoicePaymentStatusRequest] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[InvoicePaymentStatusRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/payment-status")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(request))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateBillingInfo(id: Integer,
    billingInfoRequest: Option[AddressResource] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[AddressResource]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/invoices/{id}/billing-address")
      replaceAll ("\\{" + "id" + "\\}",id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(billingInfoRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
