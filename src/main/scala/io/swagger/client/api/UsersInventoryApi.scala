/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import io.swagger.client.model.EntitlementGrantRequest
import io.swagger.client.model.EntitlementItem
import io.swagger.client.model.InvoiceResource
import io.swagger.client.model.ItemTemplateResource
import io.swagger.client.model.PageResourceEntitlementItem
import io.swagger.client.model.PageResourceItemTemplateResource
import io.swagger.client.model.PageResourceUserInventoryResource
import io.swagger.client.model.PageResourceUserItemLogResource
import io.swagger.client.model.UserInventoryAddRequest
import io.swagger.client.model.UserInventoryResource
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class UsersInventoryApi(val defBasePath: String = "https://integration.knetikcloud.com/",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Adds an item to the user inventory
   * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
   * @param id The id of the user 
   * @param userInventoryAddRequest The user inventory add request object (optional)
   * @return InvoiceResource
   */
  def addItemToUserInventory(id: Integer, userInventoryAddRequest: Option[UserInventoryAddRequest] = None): Option[InvoiceResource] = {
    // create path and map variables
    val path = "/users/{id}/inventory".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = userInventoryAddRequest.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[InvoiceResource]).asInstanceOf[InvoiceResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Check for access to an item without consuming
   * Useful for pre-check and accounts for all various buisness rules
   * @param userId The id of the user to check for or &#39;me&#39; for logged in user 
   * @param itemId The id of the item 
   * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out (optional)
   * @return void
   */
  def checkUserEntitlementItem(userId: String, itemId: Integer, sku: Option[String] = None) = {
    // create path and map variables
    val path = "/users/{user_id}/entitlements/{item_id}/check".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "item_id" + "\\}",apiInvoker.escape(itemId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (userId == null) throw new Exception("Missing required parameter 'userId' when calling UsersInventoryApi->checkUserEntitlementItem")

    sku.map(paramVal => queryParams += "sku" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Create an entitlement item
   * 
   * @param entitlementItem The entitlement item object (optional)
   * @return EntitlementItem
   */
  def createEntitlementItem(entitlementItem: Option[EntitlementItem] = None): Option[EntitlementItem] = {
    // create path and map variables
    val path = "/entitlements".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = entitlementItem.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[EntitlementItem]).asInstanceOf[EntitlementItem])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Create an entitlement template
   * Entitlement templates define a type of entitlement and the properties they have
   * @param template The entitlement template to be created (optional)
   * @return ItemTemplateResource
   */
  def createEntitlementTemplate(template: Option[ItemTemplateResource] = None): Option[ItemTemplateResource] = {
    // create path and map variables
    val path = "/entitlements/templates".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = template.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[ItemTemplateResource]).asInstanceOf[ItemTemplateResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete an entitlement item
   * 
   * @param entitlementId The id of the entitlement 
   * @return void
   */
  def deleteEntitlementItem(entitlementId: Integer) = {
    // create path and map variables
    val path = "/entitlements/{entitlement_id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "entitlement_id" + "\\}",apiInvoker.escape(entitlementId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete an entitlement template
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return void
   */
  def deleteEntitlementTemplate(id: String, cascade: Option[String] = None) = {
    // create path and map variables
    val path = "/entitlements/templates/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersInventoryApi->deleteEntitlementTemplate")

    cascade.map(paramVal => queryParams += "cascade" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get a single entitlement item
   * 
   * @param entitlementId The id of the entitlement 
   * @return EntitlementItem
   */
  def getEntitlementItem(entitlementId: Integer): Option[EntitlementItem] = {
    // create path and map variables
    val path = "/entitlements/{entitlement_id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "entitlement_id" + "\\}",apiInvoker.escape(entitlementId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[EntitlementItem]).asInstanceOf[EntitlementItem])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List and search entitlement items
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceEntitlementItem
   */
  def getEntitlementItems(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceEntitlementItem] = {
    // create path and map variables
    val path = "/entitlements".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceEntitlementItem]).asInstanceOf[PageResourceEntitlementItem])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get a single entitlement template
   * 
   * @param id The id of the template 
   * @return ItemTemplateResource
   */
  def getEntitlementTemplate(id: String): Option[ItemTemplateResource] = {
    // create path and map variables
    val path = "/entitlements/templates/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersInventoryApi->getEntitlementTemplate")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[ItemTemplateResource]).asInstanceOf[ItemTemplateResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List and search entitlement templates
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceItemTemplateResource
   */
  def getEntitlementTemplates(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceItemTemplateResource] = {
    // create path and map variables
    val path = "/entitlements/templates".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceItemTemplateResource]).asInstanceOf[PageResourceItemTemplateResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List the user inventory entries for a given user
   * 
   * @param id The id of the user 
   * @param inactive If true, accepts inactive user inventories (optional, default to false)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param filterItemName Filter by items whose name starts with a string (optional)
   * @param filterMinDate Filter for inventory added after the specified date, unix timestamp in seconds (optional)
   * @param filterMaxDate Filter for inventory added before the specified date, unix timestamp in seconds (optional)
   * @return PageResourceUserInventoryResource
   */
  def getUserInventories(id: Integer, inactive: Option[Boolean] /* = false*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, filterItemName: Option[String] = None, filterMinDate: Option[Long] = None, filterMaxDate: Option[Long] = None): Option[PageResourceUserInventoryResource] = {
    // create path and map variables
    val path = "/users/{id}/inventory".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    inactive.map(paramVal => queryParams += "inactive" -> paramVal.toString)
    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    filterItemName.map(paramVal => queryParams += "filter_item_name" -> paramVal.toString)
    filterMinDate.map(paramVal => queryParams += "filter_min_date" -> paramVal.toString)
    filterMaxDate.map(paramVal => queryParams += "filter_max_date" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceUserInventoryResource]).asInstanceOf[PageResourceUserInventoryResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get an inventory entry
   * 
   * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user 
   * @param id The id of the user inventory 
   * @return UserInventoryResource
   */
  def getUserInventory(userId: Integer, id: Integer): Option[UserInventoryResource] = {
    // create path and map variables
    val path = "/users/{user_id}/inventory/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[UserInventoryResource]).asInstanceOf[UserInventoryResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List the log entries for this inventory entry
   * 
   * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user 
   * @param id The id of the user inventory 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @return PageResourceUserItemLogResource
   */
  def getUserInventoryLog(userId: String, id: Integer, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/): Option[PageResourceUserItemLogResource] = {
    // create path and map variables
    val path = "/users/{user_id}/inventory/{id}/log".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (userId == null) throw new Exception("Missing required parameter 'userId' when calling UsersInventoryApi->getUserInventoryLog")

    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceUserItemLogResource]).asInstanceOf[PageResourceUserItemLogResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List the user inventory entries for all users
   * 
   * @param inactive If true, accepts inactive user inventories (optional, default to false)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param filterItemName Filter by items whose name starts with a string (optional)
   * @param filterUsername Filter by entries owned by the user with the specified username (optional)
   * @param filterGroup Filter by entries owned by the users in a given group, by unique name (optional)
   * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @return PageResourceUserInventoryResource
   */
  def getUsersInventory(inactive: Option[Boolean] /* = false*/, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, filterItemName: Option[String] = None, filterUsername: Option[String] = None, filterGroup: Option[String] = None, filterDate: Option[String] = None): Option[PageResourceUserInventoryResource] = {
    // create path and map variables
    val path = "/inventories".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    inactive.map(paramVal => queryParams += "inactive" -> paramVal.toString)
    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    filterItemName.map(paramVal => queryParams += "filter_item_name" -> paramVal.toString)
    filterUsername.map(paramVal => queryParams += "filter_username" -> paramVal.toString)
    filterGroup.map(paramVal => queryParams += "filter_group" -> paramVal.toString)
    filterDate.map(paramVal => queryParams += "filter_date" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceUserInventoryResource]).asInstanceOf[PageResourceUserInventoryResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Grant an entitlement
   * 
   * @param userId The id of the user to grant the entitlement to 
   * @param grantRequest grantRequest 
   * @return void
   */
  def grantUserEntitlement(userId: Integer, grantRequest: EntitlementGrantRequest) = {
    // create path and map variables
    val path = "/users/{user_id}/entitlements".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (grantRequest == null) throw new Exception("Missing required parameter 'grantRequest' when calling UsersInventoryApi->grantUserEntitlement")

    

    var postBody: AnyRef = grantRequest

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update an entitlement item
   * 
   * @param entitlementId The id of the entitlement 
   * @param entitlementItem The entitlement item object (optional)
   * @return void
   */
  def updateEntitlementItem(entitlementId: Integer, entitlementItem: Option[EntitlementItem] = None) = {
    // create path and map variables
    val path = "/entitlements/{entitlement_id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "entitlement_id" + "\\}",apiInvoker.escape(entitlementId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = entitlementItem.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update an entitlement template
   * 
   * @param id The id of the template 
   * @param template The updated template (optional)
   * @return void
   */
  def updateEntitlementTemplate(id: String, template: Option[ItemTemplateResource] = None) = {
    // create path and map variables
    val path = "/entitlements/templates/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling UsersInventoryApi->updateEntitlementTemplate")

    

    var postBody: AnyRef = template.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Set the behavior data for an inventory entry
   * 
   * @param userId The id of the user 
   * @param id The id of the user inventory 
   * @param data The data map (optional)
   * @return void
   */
  def updateUserInventoryBehaviorData(userId: Integer, id: Integer, data: Option[Any] = None) = {
    // create path and map variables
    val path = "/users/{user_id}/inventory/{id}/behavior-data".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = data.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Set the expiration date
   * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
   * @param userId user_id 
   * @param id The id of the user inventory 
   * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body). (optional)
   * @return void
   */
  def updateUserInventoryExpires(userId: Integer, id: Integer, timestamp: Option[Long] = None) = {
    // create path and map variables
    val path = "/users/{user_id}/inventory/{id}/expires".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = timestamp.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Set the status for an inventory entry
   * 
   * @param userId The id of the user 
   * @param id The id of the user inventory 
   * @param inventoryStatus The inventory status object (optional)
   * @return void
   */
  def updateUserInventoryStatus(userId: Integer, id: Integer, inventoryStatus: Option[String] = None) = {
    // create path and map variables
    val path = "/users/{user_id}/inventory/{id}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = inventoryStatus.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Use an item
   * 
   * @param userId The id of the user to check for or &#39;me&#39; for logged in user 
   * @param itemId The id of the item 
   * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out (optional)
   * @param info Any additional info to add to the log about this use (optional)
   * @return void
   */
  def useUserEntitlementItem(userId: String, itemId: Integer, sku: Option[String] = None, info: Option[String] = None) = {
    // create path and map variables
    val path = "/users/{user_id}/entitlements/{item_id}/use".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "item_id" + "\\}",apiInvoker.escape(itemId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (userId == null) throw new Exception("Missing required parameter 'userId' when calling UsersInventoryApi->useUserEntitlementItem")

    sku.map(paramVal => queryParams += "sku" -> paramVal.toString)
    info.map(paramVal => queryParams += "info" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
