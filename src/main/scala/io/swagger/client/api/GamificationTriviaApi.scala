/**
 * Knetik Platform API Documentation Latest
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: Latest
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import io.swagger.client.model.AnswerResource
import io.swagger.client.model.Collectionstring
import io.swagger.client.model.DeltaResource
import io.swagger.client.model.ImportJobResource
import io.swagger.client.model.PageImportJobResource
import io.swagger.client.model.PageQuestionResource
import io.swagger.client.model.PageQuestionTemplateResource
import io.swagger.client.model.QuestionResource
import io.swagger.client.model.QuestionTemplateResource
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class GamificationTriviaApi(val defBasePath: String = "https://devsandbox.knetikcloud.com/",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Add an answer to a question
   * 
   * @param questionId The id of the question 
   * @param answer The new answer (optional)
   * @return AnswerResource
   */
  def addAnswersUsingPOST(questionId: String, answer: Option[AnswerResource] = None): Option[AnswerResource] = {
    // create path and map variables
    val path = "/trivia/questions/{question_id}/answers".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "question_id" + "\\}",apiInvoker.escape(questionId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (questionId == null) throw new Exception("Missing required parameter 'questionId' when calling GamificationTriviaApi->addAnswersUsingPOST")

    

    var postBody: AnyRef = answer.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[AnswerResource]).asInstanceOf[AnswerResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Add a tag to a question
   * 
   * @param id The id of the question 
   * @param tag The new tag (optional)
   * @return void
   */
  def addTagUsingPOST(id: String, tag: Option[String] = None) = {
    // create path and map variables
    val path = "/trivia/questions/{id}/tags".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->addTagUsingPOST")

    

    var postBody: AnyRef = tag.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Add a tag to a batch of questions
   * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
   * @param tag The tag to add (optional)
   * @param filterSearch Filter for documents whose question, answers or tags contains provided string (optional)
   * @param filterIdset Filter for documents whose id is in the comma separated list provided (optional)
   * @param filterCategory Filter for questions with specified category, by id (optional)
   * @param filterTag Filter for questions with specified tag (optional)
   * @param filterTagset Filter for questions with specified tags (separated by comma) (optional)
   * @param filterType Filter for questions with specified type (optional)
   * @param filterPublished Filter for questions currenctly published or not (optional)
   * @param filterImportId Filter for questions from a specific import job (optional)
   * @return Integer
   */
  def batchAddTagUsingPOST(tag: Option[String] = None, filterSearch: Option[String] = None, filterIdset: Option[String] = None, filterCategory: Option[String] = None, filterTag: Option[String] = None, filterTagset: Option[String] = None, filterType: Option[String] = None, filterPublished: Option[Boolean] = None, filterImportId: Option[Long] = None): Option[Integer] = {
    // create path and map variables
    val path = "/trivia/questions/tags".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    filterSearch.map(paramVal => queryParams += "filter_search" -> paramVal.toString)
    filterIdset.map(paramVal => queryParams += "filter_idset" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterTag.map(paramVal => queryParams += "filter_tag" -> paramVal.toString)
    filterTagset.map(paramVal => queryParams += "filter_tagset" -> paramVal.toString)
    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterPublished.map(paramVal => queryParams += "filter_published" -> paramVal.toString)
    filterImportId.map(paramVal => queryParams += "filter_import_id" -> paramVal.toString)
    

    var postBody: AnyRef = tag.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[Integer]).asInstanceOf[Integer])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Remove a tag from a batch of questions
   * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
   * @param tag The tag to remove 
   * @param filterSearch Filter for documents whose question, answers or tags contains provided string (optional)
   * @param filterIdset Filter for documents whose id is in the comma separated list provided (optional)
   * @param filterCategory Filter for questions with specified category, by id (optional)
   * @param filterTag Filter for questions with specified tag (optional)
   * @param filterTagset Filter for questions with specified tags (separated by comma) (optional)
   * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)
   * @param filterPublished Filter for questions currenctly published or not (optional)
   * @param filterImportId Filter for questions from a specific import job (optional)
   * @return Integer
   */
  def batchRemoveTagUsingDELETE(tag: String, filterSearch: Option[String] = None, filterIdset: Option[String] = None, filterCategory: Option[String] = None, filterTag: Option[String] = None, filterTagset: Option[String] = None, filterType: Option[String] = None, filterPublished: Option[Boolean] = None, filterImportId: Option[Long] = None): Option[Integer] = {
    // create path and map variables
    val path = "/trivia/questions/tags/{tag}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "tag" + "\\}",apiInvoker.escape(tag))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (tag == null) throw new Exception("Missing required parameter 'tag' when calling GamificationTriviaApi->batchRemoveTagUsingDELETE")

    filterSearch.map(paramVal => queryParams += "filter_search" -> paramVal.toString)
    filterIdset.map(paramVal => queryParams += "filter_idset" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterTag.map(paramVal => queryParams += "filter_tag" -> paramVal.toString)
    filterTagset.map(paramVal => queryParams += "filter_tagset" -> paramVal.toString)
    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterPublished.map(paramVal => queryParams += "filter_published" -> paramVal.toString)
    filterImportId.map(paramVal => queryParams += "filter_import_id" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[Integer]).asInstanceOf[Integer])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Bulk update questions
   * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
   * @param question New values for a set of question fields (optional)
   * @param filterSearch Filter for documents whose question, answers or tags contains provided string (optional)
   * @param filterIdset Filter for documents whose id is in the comma separated list provided (optional)
   * @param filterCategory Filter for questions with specified category, by id (optional)
   * @param filterTagset Filter for questions with specified tags (separated by comma) (optional)
   * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)
   * @param filterPublished Filter for questions currenctly published or not (optional)
   * @param filterImportId Filter for questions from a specific import job (optional)
   * @return Integer
   */
  def bulkUpdateUsingPUT(question: Option[QuestionResource] = None, filterSearch: Option[String] = None, filterIdset: Option[String] = None, filterCategory: Option[String] = None, filterTagset: Option[String] = None, filterType: Option[String] = None, filterPublished: Option[Boolean] = None, filterImportId: Option[Long] = None): Option[Integer] = {
    // create path and map variables
    val path = "/trivia/questions".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    filterSearch.map(paramVal => queryParams += "filter_search" -> paramVal.toString)
    filterIdset.map(paramVal => queryParams += "filter_idset" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterTagset.map(paramVal => queryParams += "filter_tagset" -> paramVal.toString)
    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterPublished.map(paramVal => queryParams += "filter_published" -> paramVal.toString)
    filterImportId.map(paramVal => queryParams += "filter_import_id" -> paramVal.toString)
    

    var postBody: AnyRef = question.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[Integer]).asInstanceOf[Integer])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Count questions based on filters.
   * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
   * @param filterSearch Filter for documents whose question, answers or tags contains provided string (optional)
   * @param filterIdset Filter for documents whose id is in the comma separated list provided (optional)
   * @param filterCategory Filter for questions with specified category, by id (optional)
   * @param filterTag Filter for questions with specified tag (optional)
   * @param filterTagset Filter for questions with specified tags (separated by comma) (optional)
   * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)
   * @param filterPublished Filter for questions currenctly published or not (optional)
   * @return Long
   */
  def countQuestionsUsingGET(filterSearch: Option[String] = None, filterIdset: Option[String] = None, filterCategory: Option[String] = None, filterTag: Option[String] = None, filterTagset: Option[String] = None, filterType: Option[String] = None, filterPublished: Option[Boolean] = None): Option[Long] = {
    // create path and map variables
    val path = "/trivia/questions/count".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    filterSearch.map(paramVal => queryParams += "filter_search" -> paramVal.toString)
    filterIdset.map(paramVal => queryParams += "filter_idset" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterTag.map(paramVal => queryParams += "filter_tag" -> paramVal.toString)
    filterTagset.map(paramVal => queryParams += "filter_tagset" -> paramVal.toString)
    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterPublished.map(paramVal => queryParams += "filter_published" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[Long]).asInstanceOf[Long])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Create a question template
   * Question templates define a type of question and the properties they have
   * @param questionTemplateResource The question template resource object (optional)
   * @return QuestionTemplateResource
   */
  def createQuestionTemplateUsingPOST(questionTemplateResource: Option[QuestionTemplateResource] = None): Option[QuestionTemplateResource] = {
    // create path and map variables
    val path = "/trivia/questions/templates".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = questionTemplateResource.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[QuestionTemplateResource]).asInstanceOf[QuestionTemplateResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Create a question
   * 
   * @param question The new question (optional)
   * @return QuestionResource
   */
  def createQuestionUsingPOST(question: Option[QuestionResource] = None): Option[QuestionResource] = {
    // create path and map variables
    val path = "/trivia/questions".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = question.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[QuestionResource]).asInstanceOf[QuestionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Create an import job
   * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
   * @param request The new import job (optional)
   * @return ImportJobResource
   */
  def createUsingPOST(request: Option[ImportJobResource] = None): Option[ImportJobResource] = {
    // create path and map variables
    val path = "/trivia/import".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = request.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[ImportJobResource]).asInstanceOf[ImportJobResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete a question template
   * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
   * @param id The id of the template 
   * @param cascade The value needed to delete used templates (optional)
   * @return void
   */
  def deleteQuestionTemplateUsingDELETE(id: String, cascade: Option[String] = None) = {
    // create path and map variables
    val path = "/trivia/questions/templates/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->deleteQuestionTemplateUsingDELETE")

    cascade.map(paramVal => queryParams += "cascade" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete a question
   * 
   * @param id The id of the question 
   * @return void
   */
  def deleteQuestionUsingDELETE(id: String) = {
    // create path and map variables
    val path = "/trivia/questions/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->deleteQuestionUsingDELETE")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Delete an import job
   * Also deletes all questions that were imported by it
   * @param id The id of the job 
   * @return void
   */
  def deleteUsingDELETE(id: Long) = {
    // create path and map variables
    val path = "/trivia/import/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get an answer for a question
   * 
   * @param questionId The id of the question 
   * @param id The id of the answer 
   * @return AnswerResource
   */
  def getAnswerUsingGET(questionId: String, id: String): Option[AnswerResource] = {
    // create path and map variables
    val path = "/trivia/questions/{question_id}/answers/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "question_id" + "\\}",apiInvoker.escape(questionId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (questionId == null) throw new Exception("Missing required parameter 'questionId' when calling GamificationTriviaApi->getAnswerUsingGET")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->getAnswerUsingGET")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[AnswerResource]).asInstanceOf[AnswerResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List the answers available for a question
   * 
   * @param questionId The id of the question 
   * @return List[AnswerResource]
   */
  def getAnswersUsingGET(questionId: String): Option[List[AnswerResource]] = {
    // create path and map variables
    val path = "/trivia/questions/{question_id}/answers".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "question_id" + "\\}",apiInvoker.escape(questionId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (questionId == null) throw new Exception("Missing required parameter 'questionId' when calling GamificationTriviaApi->getAnswersUsingGET")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "array", classOf[AnswerResource]).asInstanceOf[List[AnswerResource]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get a list of import job
   * 
   * @param filterVendor Filter for jobs by vendor id (optional)
   * @param filterCategory Filter for jobs by category id (optional)
   * @param filterName Filter for jobs which name *STARTS* with the given string (optional)
   * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated) (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to 1)
   * @return PageImportJobResource
   */
  def getListUsingGET1(filterVendor: Option[String] = None, filterCategory: Option[String] = None, filterName: Option[String] = None, filterStatus: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = 1*/): Option[PageImportJobResource] = {
    // create path and map variables
    val path = "/trivia/import".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    filterVendor.map(paramVal => queryParams += "filter_vendor" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterName.map(paramVal => queryParams += "filter_name" -> paramVal.toString)
    filterStatus.map(paramVal => queryParams += "filter_status" -> paramVal.toString)
    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PageImportJobResource]).asInstanceOf[PageImportJobResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get a single question template
   * 
   * @param id The id of the template 
   * @return QuestionTemplateResource
   */
  def getQuestionTemplateUsingGET(id: String): Option[QuestionTemplateResource] = {
    // create path and map variables
    val path = "/trivia/questions/templates/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->getQuestionTemplateUsingGET")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[QuestionTemplateResource]).asInstanceOf[QuestionTemplateResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List and search question templates
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to 1)
   * @return PageQuestionTemplateResource
   */
  def getQuestionTemplatesUsingGET(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = 1*/): Option[PageQuestionTemplateResource] = {
    // create path and map variables
    val path = "/trivia/questions/templates".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PageQuestionTemplateResource]).asInstanceOf[PageQuestionTemplateResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get a single question
   * 
   * @param id The id of the question 
   * @return QuestionResource
   */
  def getQuestionUsingGET(id: String): Option[QuestionResource] = {
    // create path and map variables
    val path = "/trivia/questions/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->getQuestionUsingGET")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[QuestionResource]).asInstanceOf[QuestionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List question deltas in ascending order of updated date
   * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
   * @param since Timestamp in seconds (optional)
   * @return List[DeltaResource]
   */
  def getQuestionsDeltaUsingGET(since: Option[Long] = None): Option[List[DeltaResource]] = {
    // create path and map variables
    val path = "/trivia/questions/delta".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    since.map(paramVal => queryParams += "since" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "array", classOf[DeltaResource]).asInstanceOf[List[DeltaResource]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List and search questions
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to 1)
   * @param filterSearch Filter for documents whose question, answers or tags contains provided string (optional)
   * @param filterIdset Filter for documents whose id is in the comma separated list provided (optional)
   * @param filterCategory Filter for questions with specified category, by id (optional)
   * @param filterTagset Filter for questions with specified tags (separated by comma) (optional)
   * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)
   * @param filterPublished Filter for questions currenctly published or not (optional)
   * @param filterImportId Filter for questions from a specific import job (optional)
   * @return PageQuestionResource
   */
  def getQuestionsUsingGET(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = 1*/, filterSearch: Option[String] = None, filterIdset: Option[String] = None, filterCategory: Option[String] = None, filterTagset: Option[String] = None, filterType: Option[String] = None, filterPublished: Option[Boolean] = None, filterImportId: Option[Long] = None): Option[PageQuestionResource] = {
    // create path and map variables
    val path = "/trivia/questions".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    filterSearch.map(paramVal => queryParams += "filter_search" -> paramVal.toString)
    filterIdset.map(paramVal => queryParams += "filter_idset" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterTagset.map(paramVal => queryParams += "filter_tagset" -> paramVal.toString)
    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterPublished.map(paramVal => queryParams += "filter_published" -> paramVal.toString)
    filterImportId.map(paramVal => queryParams += "filter_import_id" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[PageQuestionResource]).asInstanceOf[PageQuestionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List the tags for a question
   * 
   * @param id The id of the question 
   * @return List[String]
   */
  def getTagsUsingGET1(id: String): Option[List[String]] = {
    // create path and map variables
    val path = "/trivia/questions/{id}/tags".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->getTagsUsingGET1")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "array", classOf[String]).asInstanceOf[List[String]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List and search tags by the beginning of the string
   * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
   * @param filterSearch Filter for tags starting with the given text (optional)
   * @param filterCategory Filter for tags on questions from a specific category (optional)
   * @param filterImportId Filter for tags on questions from a specific import job (optional)
   * @return Collectionstring
   */
  def getTagsUsingGET2(filterSearch: Option[String] = None, filterCategory: Option[String] = None, filterImportId: Option[Long] = None): Option[Collectionstring] = {
    // create path and map variables
    val path = "/trivia/tags".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    filterSearch.map(paramVal => queryParams += "filter_search" -> paramVal.toString)
    filterCategory.map(paramVal => queryParams += "filter_category" -> paramVal.toString)
    filterImportId.map(paramVal => queryParams += "filter_import_id" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[Collectionstring]).asInstanceOf[Collectionstring])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get an import job
   * 
   * @param id The id of the job 
   * @return ImportJobResource
   */
  def getUsingGET(id: Long): Option[ImportJobResource] = {
    // create path and map variables
    val path = "/trivia/import/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[ImportJobResource]).asInstanceOf[ImportJobResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Remove an answer from a question
   * 
   * @param questionId The id of the question 
   * @param id The id of the answer 
   * @return void
   */
  def removeAnswersUsingDELETE(questionId: String, id: String) = {
    // create path and map variables
    val path = "/trivia/questions/{question_id}/answers/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "question_id" + "\\}",apiInvoker.escape(questionId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (questionId == null) throw new Exception("Missing required parameter 'questionId' when calling GamificationTriviaApi->removeAnswersUsingDELETE")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->removeAnswersUsingDELETE")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Remove a tag from a question
   * 
   * @param id The id of the question 
   * @param tag The tag to remove 
   * @return void
   */
  def removeTagUsingDELETE(id: String, tag: String) = {
    // create path and map variables
    val path = "/trivia/questions/{id}/tags/{tag}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id)).replaceAll("\\{" + "tag" + "\\}",apiInvoker.escape(tag))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->removeTagUsingDELETE")

    if (tag == null) throw new Exception("Missing required parameter 'tag' when calling GamificationTriviaApi->removeTagUsingDELETE")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Start processing an import job
   * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
   * @param id The id of the job 
   * @param publishNow Whether the new questions should be published live immediately 
   * @return ImportJobResource
   */
  def startProcessUsingPOST(id: Long, publishNow: Boolean): Option[ImportJobResource] = {
    // create path and map variables
    val path = "/trivia/import/{id}/process".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    queryParams += "publish_now" -> publishNow.toString
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[ImportJobResource]).asInstanceOf[ImportJobResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update an answer for a question
   * 
   * @param questionId The id of the question 
   * @param id The id of the answer 
   * @param answer The updated answer (optional)
   * @return void
   */
  def updateAnswerUsingPUT(questionId: String, id: String, answer: Option[AnswerResource] = None) = {
    // create path and map variables
    val path = "/trivia/questions/{question_id}/answers/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "question_id" + "\\}",apiInvoker.escape(questionId)).replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (questionId == null) throw new Exception("Missing required parameter 'questionId' when calling GamificationTriviaApi->updateAnswerUsingPUT")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->updateAnswerUsingPUT")

    

    var postBody: AnyRef = answer.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update a question template
   * 
   * @param id The id of the template 
   * @param questionTemplateResource The question template resource object (optional)
   * @return void
   */
  def updateQuestionTemplateUsingPUT(id: String, questionTemplateResource: Option[QuestionTemplateResource] = None) = {
    // create path and map variables
    val path = "/trivia/questions/templates/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->updateQuestionTemplateUsingPUT")

    

    var postBody: AnyRef = questionTemplateResource.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update a question
   * 
   * @param id The id of the question 
   * @param question The updated question (optional)
   * @return QuestionResource
   */
  def updateQuestionUsingPUT(id: String, question: Option[QuestionResource] = None): Option[QuestionResource] = {
    // create path and map variables
    val path = "/trivia/questions/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GamificationTriviaApi->updateQuestionUsingPUT")

    

    var postBody: AnyRef = question.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[QuestionResource]).asInstanceOf[QuestionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Update an import job
   * Changes should be made before process is started for there to be any effect.
   * @param id The id of the job 
   * @param request The updated job (optional)
   * @return ImportJobResource
   */
  def updateUsingPUT(id: Long, request: Option[ImportJobResource] = None): Option[ImportJobResource] = {
    // create path and map variables
    val path = "/trivia/import/{id}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "id" + "\\}",apiInvoker.escape(id))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = request.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(ApiInvoker.deserialize(s, "", classOf[ImportJobResource]).asInstanceOf[ImportJobResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
