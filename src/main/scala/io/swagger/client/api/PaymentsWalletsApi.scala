/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import io.swagger.client.model.PageResourceSimpleWallet
import io.swagger.client.model.PageResourceWalletTotalResponse
import io.swagger.client.model.PageResourceWalletTransactionResource
import io.swagger.client.model.Result
import io.swagger.client.model.SimpleWallet
import io.swagger.client.model.WalletAlterRequest
import io.swagger.client.model.WalletTransactionResource
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class PaymentsWalletsApi(val defBasePath: String = "https://localhost:8080/",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Returns the user&#39;s wallet for the given currency code
   * 
   * @param userId The ID of the user for whom wallet is being retrieved 
   * @param currencyCode Currency code of the user&#39;s wallet 
   * @return SimpleWallet
   */
  def getUserWallet(userId: Integer, currencyCode: String): Option[SimpleWallet] = {
    // create path and map variables
    val path = "/users/{user_id}/wallets/{currency_code}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "currency_code" + "\\}",apiInvoker.escape(currencyCode))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (currencyCode == null) throw new Exception("Missing required parameter 'currencyCode' when calling PaymentsWalletsApi->getUserWallet")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[SimpleWallet]).asInstanceOf[SimpleWallet])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Retrieve a user&#39;s wallet transactions
   * 
   * @param userId The ID of the user for whom wallet transactions are being retrieved 
   * @param currencyCode Currency code of the user&#39;s wallet 
   * @param filterType Filter for transactions with specified type (optional)
   * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds (optional)
   * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds (optional)
   * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;) (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceWalletTransactionResource
   */
  def getUserWalletTransactions(userId: Integer, currencyCode: String, filterType: Option[String] = None, filterMaxDate: Option[Long] = None, filterMinDate: Option[Long] = None, filterSign: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceWalletTransactionResource] = {
    // create path and map variables
    val path = "/users/{user_id}/wallets/{currency_code}/transactions".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "currency_code" + "\\}",apiInvoker.escape(currencyCode))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (currencyCode == null) throw new Exception("Missing required parameter 'currencyCode' when calling PaymentsWalletsApi->getUserWalletTransactions")

    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterMaxDate.map(paramVal => queryParams += "filter_max_date" -> paramVal.toString)
    filterMinDate.map(paramVal => queryParams += "filter_min_date" -> paramVal.toString)
    filterSign.map(paramVal => queryParams += "filter_sign" -> paramVal.toString)
    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceWalletTransactionResource]).asInstanceOf[PageResourceWalletTransactionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List all of a user&#39;s wallets
   * 
   * @param userId The ID of the user for whom wallets are being retrieved 
   * @return List[SimpleWallet]
   */
  def getUserWallets(userId: Integer): Option[List[SimpleWallet]] = {
    // create path and map variables
    val path = "/users/{user_id}/wallets".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[SimpleWallet]).asInstanceOf[List[SimpleWallet]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Retrieves a summation of wallet balances by currency code
   * 
   * @return PageResourceWalletTotalResponse
   */
  def getWalletBalances(): Option[PageResourceWalletTotalResponse] = {
    // create path and map variables
    val path = "/wallets/totals".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceWalletTotalResponse]).asInstanceOf[PageResourceWalletTotalResponse])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Retrieve wallet transactions across the system
   * 
   * @param filterInvoice Filter for transactions from a specific invoice (optional)
   * @param filterType Filter for transactions with specified type (optional)
   * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE). (optional)
   * @param filterSign Filter for transactions with amount with the given sign (optional)
   * @param filterUserId Filter for transactions for specific userId (optional)
   * @param filterUsername Filter for transactions for specific username that start with the given string (optional)
   * @param filterDetails Filter for transactions for specific details that start with the given string (optional)
   * @param filterCurrencyCode Filter for transactions for specific currency code (optional)
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceWalletTransactionResource
   */
  def getWalletTransactions(filterInvoice: Option[Integer] = None, filterType: Option[String] = None, filterDate: Option[String] = None, filterSign: Option[String] = None, filterUserId: Option[Integer] = None, filterUsername: Option[String] = None, filterDetails: Option[String] = None, filterCurrencyCode: Option[String] = None, size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceWalletTransactionResource] = {
    // create path and map variables
    val path = "/wallets/transactions".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    filterInvoice.map(paramVal => queryParams += "filter_invoice" -> paramVal.toString)
    filterType.map(paramVal => queryParams += "filter_type" -> paramVal.toString)
    filterDate.map(paramVal => queryParams += "filter_date" -> paramVal.toString)
    filterSign.map(paramVal => queryParams += "filter_sign" -> paramVal.toString)
    filterUserId.map(paramVal => queryParams += "filter_user_id" -> paramVal.toString)
    filterUsername.map(paramVal => queryParams += "filter_username" -> paramVal.toString)
    filterDetails.map(paramVal => queryParams += "filter_details" -> paramVal.toString)
    filterCurrencyCode.map(paramVal => queryParams += "filter_currency_code" -> paramVal.toString)
    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceWalletTransactionResource]).asInstanceOf[PageResourceWalletTransactionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Retrieve a list of wallets across the system
   * 
   * @param size The number of objects returned per page (optional, default to 25)
   * @param page The number of the page returned, starting with 1 (optional, default to 1)
   * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)
   * @return PageResourceSimpleWallet
   */
  def getWallets(size: Option[Integer] /* = 25*/, page: Option[Integer] /* = 1*/, order: Option[String] /* = id:ASC*/): Option[PageResourceSimpleWallet] = {
    // create path and map variables
    val path = "/wallets".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    size.map(paramVal => queryParams += "size" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    order.map(paramVal => queryParams += "order" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[PageResourceSimpleWallet]).asInstanceOf[PageResourceSimpleWallet])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Updates the balance for a user&#39;s wallet
   * 
   * @param userId The ID of the user for whom wallet is being modified 
   * @param currencyCode Currency code of the user&#39;s wallet 
   * @param request The requested balance modification to be made to the user&#39;s wallet (optional)
   * @return WalletTransactionResource
   */
  def updateWalletBalance(userId: Integer, currencyCode: String, request: Option[WalletAlterRequest] = None): Option[WalletTransactionResource] = {
    // create path and map variables
    val path = "/users/{user_id}/wallets/{currency_code}/balance".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "user_id" + "\\}",apiInvoker.escape(userId)).replaceAll("\\{" + "currency_code" + "\\}",apiInvoker.escape(currencyCode))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (currencyCode == null) throw new Exception("Missing required parameter 'currencyCode' when calling PaymentsWalletsApi->updateWalletBalance")

    

    var postBody: AnyRef = request.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[WalletTransactionResource]).asInstanceOf[WalletTransactionResource])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
